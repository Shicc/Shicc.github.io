<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>GeekShi</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://shic.top/"/>
  <updated>2017-10-06T14:44:54.380Z</updated>
  <id>http://shic.top/</id>
  
  <author>
    <name>this.Shi</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Spring Boot的Controller注解</title>
    <link href="http://shic.top/2017/10/06/controller/"/>
    <id>http://shic.top/2017/10/06/controller/</id>
    <published>2017-10-05T16:00:00.000Z</published>
    <updated>2017-10-06T14:44:54.380Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-5-7-RELEASE版本中的Controller注解"><a href="#1-5-7-RELEASE版本中的Controller注解" class="headerlink" title="1.5.7. RELEASE版本中的Controller注解"></a>1.5.7. RELEASE版本中的Controller注解</h2><p><strong>当你发现教程和你想使用的某个东西版本不一样的时候，总会觉得有些打脑壳</strong><br><a id="more"></a></p>
<center><img src="http://res.cloudinary.com/shi1996/image/upload/v1507300798/%E6%89%93%E8%84%91%E5%A3%B3_v6bqgj.jpg" alt="打脑壳"></center><br><center>说得又想放表情包了，先往下看。。。</center><br>1. 环境及IDE：<br>  <em> JDK 1.8
  </em> Spring Boot 1.5.7.RELEASE<br>  <em> maven 3.5
  </em> IntelliJ IDEA 2017.1.1<br><br>2. 问题由来：<br> <em> 教程使用的是Spring Boot 1.4.1
 </em> 我使用的是1.5.7.RELEASE<br><br>3. 问题出现：<br> <em> 在使用Controller注解时，1.4.1就会出现500的错误（服务器内部错误），但是我用的1.5.7. RELEASE版本，就没有500的错误，但是有404错误。<br><br>4. 分析与思考：
 </em> 500的服务器错误就是因为：<strong>1.4.1版本需要使用到模板，然后方法返回一个字符串去匹配同名的视图</strong>，但是1.5.7. RELEASE版本是404错误，感觉就不是服务器出错了，只是说404错误，是找不到页面，<strong>那按照这个道理来说，1.5.7. RELEASE版本在用配置好的URL访问时就不是因为缺少模板文件导致的了</strong>。<br> <em> 通过查看了一下1.4.1需要怎么使用模板文件发现还是比较麻烦的，要是之后的版本取消这么使用就好了。<br><br>5. 于是去spring boot官网找答案：
 </em> 其中给的例子是：<br>   <pre><code><br>    package hello;<br><br>    import org.springframework.boot.<em>;<br>    import org.springframework.boot.autoconfigure.</em>;<br>    import org.springframework.stereotype.<em>;<br>    import org.springframework.web.bind.annotation.</em>;<br><br>    @Controller<br>    @EnableAutoConfiguration<br>    public class SampleController {<br><br>    @RequestMapping(“/“)<br>    @ResponseBody<br>    String home() {<br>        return “Hello World!”;<br>        }<br><br>    public static void main(String[] args) throws Exception {<br>        SpringApplication.run(SampleController.class, args);<br>        }<br>    }<br>   </code></pre><br><br>6. @Controller对比@RestController：<br> <em> @RestController在声明类前面注释之后，在需要通过URL访问的方法前面注释@RequestMapping()就行了
 </em> @Controller多了两个注释：一是@Controller下方的@EnableAutoConfiguration，二是方法前的@ResponseBody，<em>*实测只需要@ResponseBody就能成功访问了而不会出现404错误。（ResponseBody意思就是注解一下回复的主体吧，这样就很好理解了）
 </em> <center><img src="http://res.cloudinary.com/shi1996/image/upload/v1507301057/2_ex7c2o.png" alt="test"></center>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-5-7-RELEASE版本中的Controller注解&quot;&gt;&lt;a href=&quot;#1-5-7-RELEASE版本中的Controller注解&quot; class=&quot;headerlink&quot; title=&quot;1.5.7. RELEASE版本中的Controller注解&quot;&gt;&lt;/a&gt;1.5.7. RELEASE版本中的Controller注解&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;当你发现教程和你想使用的某个东西版本不一样的时候，总会觉得有些打脑壳&lt;/strong&gt;&lt;br&gt;
    
    </summary>
    
      <category term="IntelliJ IDEA" scheme="http://shic.top/categories/IntelliJ-IDEA/"/>
    
    
      <category term="IntelliJ IDEA" scheme="http://shic.top/tags/IntelliJ-IDEA/"/>
    
  </entry>
  
  <entry>
    <title>Python初学</title>
    <link href="http://shic.top/2017/09/27/pythonTest/"/>
    <id>http://shic.top/2017/09/27/pythonTest/</id>
    <published>2017-09-26T16:00:00.000Z</published>
    <updated>2017-09-28T06:01:05.481Z</updated>
    
    <content type="html"><![CDATA[<h2 id="初敲Python后的一些感受"><a href="#初敲Python后的一些感受" class="headerlink" title="初敲Python后的一些感受"></a><center>初敲Python后的一些感受</center></h2><ul>
<li>常敲Java的我开启了Python之路<a id="more"></a>
<ul>
<li>最开始觉得Python很方便，方便程度：Python&gt;Java&gt;C++</li>
<li>然后没看书了自己摸索直接敲，觉得Python很不友好</li>
<li>最后发现问题是自己没好好看书。。。</li>
<li>于是在今天把杂事都处理了之后我便自己实验了起来。</li>
</ul>
</li>
</ul>
<ul>
<li>我最想了解Python的项目结构。原因有二：<ul>
<li>之前学C的时候全是一个文件在玩儿，感觉就是限制了开发，毕竟一个文件要么功能单一，要么有功能但臃肿庞大不利于后期阅读。</li>
<li>之后学C++，通常是自己写需要功能然后把它们封装成类写在一个头文件里，然后以后需要用了就直接include，就特别方便，然后功能也可以实现很多。之后的Java就不多说。所以现在特别想了解一下Python的项目结构可以是什么样的，我能根据它来写出什么样的功能。    </li>
</ul>
</li>
</ul>
<p><strong>因为我没有看懂网上的教程，苦逼的我便开始了试验：</strong></p>
<ul>
<li>项目结构：<ul>
<li>hello1 D:\MyProject\PyCharmProjcet<ul>
<li>package_test<ul>
<li>_ <em>init</em> _.py </li>
<li>p_test.py</li>
<li>service_package_print.py</li>
</ul>
</li>
<li>service_obj.py</li>
<li>service_print.py</li>
<li>test.py</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>测试在根目录下从另一文件里调用函数输出，测试文件test.py</p>
<ul>
<li>service_print.py:<pre><code>
      def if_print():
      print("这是项目根目录下的if_print()")
      s=0
      for i in range(1,101):
             s+=i 
      print(s)
</code></pre></li>
<li><p>service_obj.py:</p>
<pre><code>
      class service_object:
      #如果这里写s=2，在函数里就用不了，全局没用？
      #print(s)
         print("这是项目根目录下的test_object类")
      def if_print_the_sum():
          s = 2
          for i in range(1, 201):
              s += i
          print(s)

      def if_print_str(str):
          print(str)
</code></pre></li>
<li><p>test.py</p>
<pre><code>
      import service_print
      import service_obj
      import package_test

      # service_print.if_print()
      # service_obj.test_object.if_print_the_sum()
      my_class=service_obj
      #id(my_class)
      my_class.service_object.if_print_str("my_class.service_object.if_print_str输出")
      my_object=my_class.service_object
      # id(my_object)
      my_object.if_print_str("my_object.if_print_str输出")
</code></pre></li>
<li><p>结果：<br><center><img src="https://res.cloudinary.com/shi1996/image/upload/v1506501312/pycharm_irvlcw.png" alt="pycharm"></center><br><em>* 通过实验，了解到了python与Java等语言不同：</em></p>
<ul>
<li>类名和文件名可以不同</li>
<li>一个类的实例是需要file_name.class_name来赋值，Java中文件名和类名必须是一样的，所以my_object=file_name也差不多能解释。但python里文件名和类名一样后也不行。</li>
<li>而且python里还可以直接用file_name.function_name()来执行类中方法不需要对象.#注意：是不能使用类名直接调用的。<br></li>
</ul>
</li>
<li><p>之后再测试了package里是怎么回事 ：</p>
<ul>
<li>建立package后，包里面会默认有一个_ <em>init</em> _.py 文件，暂时不知是干啥的</li>
<li>然后import 这个包，发现不会用。。</li>
<li><img src="http://res.cloudinary.com/shi1996/image/upload/v1506509094/packageTest_ort1cv.png" alt="packageTest"><blockquote>
<p>但是问了一下豆豆，她却给我说她只用过directory没用过package。。.于是我有趣尝试了一下directory,结果发现只比package少了一个_ <em>init</em> _.py，也用不了。..</p>
</blockquote>
</li>
</ul>
</li>
<li><p>但实际上，但仔细阅读Python模块定义后才明白，.py就是一个模块，而在Java中.java可以说是一个类，我们要用一个模块就像在Java中要用一个类一样，所以要</p>
<pre><code>import package_name.module_name #这样使用
</code></pre><blockquote>
<p>但很奇怪的一点是，import一个包里的模块后，例如上面这样，在使用的时候却<strong>不能直接使用里面的模块，这一点我搞不懂为什么</strong>，要package_name.module_name这样使用，例如我想使用service_package_print模块：<br><center><img src="https://res.cloudinary.com/shi1996/image/upload/v1506577897/11_t5ifhs.png" alt="service_package_print()"></center></p>
<blockquote>
<p>而我用</p>
<pre><code>from package_test import service_package_print
</code></pre><p>就直接能够使用service_package_print模块而不需要先调用包名，且想要调用直接调用包都不行，因为这里是从该包中直接import的一个模块，要是能调用包名的话，那肯定可以调用包中的其他模块，这不符合from..import..的逻辑<br><img src="http://res.cloudinary.com/shi1996/image/upload/v1506578144/12_qlxg34.png" alt="from package_test import service_package_print"></p>
</blockquote>
</blockquote>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;初敲Python后的一些感受&quot;&gt;&lt;a href=&quot;#初敲Python后的一些感受&quot; class=&quot;headerlink&quot; title=&quot;初敲Python后的一些感受&quot;&gt;&lt;/a&gt;&lt;center&gt;初敲Python后的一些感受&lt;/center&gt;&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;常敲Java的我开启了Python之路
    
    </summary>
    
      <category term="Python" scheme="http://shic.top/categories/Python/"/>
    
    
      <category term="Python" scheme="http://shic.top/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>SSD揭秘篇</title>
    <link href="http://shic.top/2017/09/17/SSD%E6%8F%AD%E7%A7%98/"/>
    <id>http://shic.top/2017/09/17/SSD揭秘/</id>
    <published>2017-09-16T16:00:10.000Z</published>
    <updated>2017-09-17T11:44:55.966Z</updated>
    
    <content type="html"><![CDATA[<h2 id="SSD何方神圣？一探究竟"><a href="#SSD何方神圣？一探究竟" class="headerlink" title="SSD何方神圣？一探究竟"></a><center>SSD何方神圣？一探究竟</center></h2><ul>
<li>认识好SSD的内在，几年不卡<br>我记得在我接触SSD初期的时候，就知道它的高性能和寿命特点，再加之这货很贵，我便觉得使用时不能马虎，万一盘挂了还不好做数据恢复，最重要的是这么贵的盘挂了，自己得多心疼啊。。。<a id="more"></a>    
</li>
</ul>
<p>于是乎，我便有了很强烈得想要了解它得想法，虽然说网上也有关于使用的一些帖子，诸如说的不要随时清理垃圾，盘不要分多了，M.2不同针脚的插槽的区别等，其实看完也很懵，我自己想要理解还是需要自己去从更加底层的原理看起，才能明白，于是我就去搞了一本书，里面还是讲了很多基础知识的：</p>
<center><img src="/images/让电脑飞/ssd.jpg" alt="SSD"></center>

<p><em>终于，了解了真相。。。知道了它是怎么回事</em></p>
<ol>
<li>首先是要了解固态的基本构成，怎么选择才能选到最好的方案</li>
<li>其次就是了解固态的运作机制，怎么的盘才是最适合自己的</li>
<li>最后要了解固态的存储机制，才能知道是怎么损耗的，才能知道怎么正确的使用</li>
</ol>
<ul>
<li><p>有了以上3点的铺垫，才能通过自己的了解，选到一个适合的SSD，且自己也会正确的使用，这在SSD价格居高不下的今天，是最最最值得思考和研究的问题，花大价钱但有优秀而长久的体验，也是很值的了，那么下面我们就分点讲解一下。</p>
</li>
<li><p></p><h3>深入了解固态硬盘</h3><br>由于要深入了解，所以我又准备分几点以问答形式来讲，方便大家的理解：<p></p>
</li>
</ul>
<ol>
<li><strong>为什么叫固态硬盘？</strong><br>答：固态硬盘的英文全称是：Solid State Disk，俗称固态盘，它内部和传统的机械硬盘不同，里面没有机械活动地组件，也不需要碟片旋转来读写数据，里面全是一块一块的固定的闪存颗粒，所以才叫固态硬盘</li>
<li><strong>NAND闪存颗粒是怎么个回事？</strong><br>答：由上一点可知，固态的存储是由固定在电路板上的闪存颗粒组成的，而这里的闪存颗粒，我们就叫的NAND闪存，NAND闪存还是分了很多种的，目前有SLC.MLC.TLC,而还有正在研发的QLC，SLC全称是Single Level Cell，即1bit/cell，特点就是速度块，寿命长，但是它的成本很高，SLC利用正负两种电荷，一个浮动栅存储1bit的信息，其擦写次数约10万次的PE（擦写），MLC全称是Multi  Level Cell，即2bit/cell，特点是速度中等，寿命中等，价格也处于中等水平。利用不同电位的电荷，一个浮动栅存储2bit的数据，约3000~10000次的PE，而TLC颗粒。即Triple Level Cell，3bit/cell，是三者之中速度最慢，寿命最短，价格也最低的。虽然如此，但是TLC颗粒都要比机械硬盘的存储速度快很多。但TLC颗粒的SSD也是机械硬盘的几倍价格，所以目前亲民的一些SSD基本都是TLC颗粒的。</li>
<li><p><strong>固态硬盘的不同接口是？</strong><br>答：此处我们只讲两个最常见的接口，因为相对值得购买的产品也是这两大接口最多做好选。分别是SATA和m.2（顺带一点PEI-E）</p>
<p>（1）.SATA：首先要明确一点，SATA接口在机械硬盘时期的确辉煌过，它从SATA1.0（大概150MB/s）升级到了现在的SATA3.0(大概600MB/s)，机械硬盘的速度根本喂不饱它，但是到了固态硬盘流行的年代，最高6Gbps的速率封顶也就768MB/s，现在动辄就彪2000MB/s+的速率的NVMe SSD早已不在适合搭配SATA接口了，如果你电脑只能装SATA的SSD，那么可以购买相关产品去给老电脑升级，如果不是的话，那这类产品就不用去考虑了。当然有些笔记本电脑可能有mSATA接口，它本质上还是SATA，只不过是比标准版的外观规格要小，性能都是一样的。适合于轻薄设备，但价格也比SATA贵，还不如改光驱的方案来的划算。<br>（2）.m.2:该接口最开始是在2012年由英特尔等厂商提出的固态硬盘适用的接口，最初叫做NGFF，最终命名为了m.2(M.2)，因为期接口小巧，且能配合PCI-e通道进行使用，性能是非常强悍，目前是市面上最为火热的固态接口之一，当然还有就是以PCI-e形式存在的SSD，一般为台式机使用，直接插在主办上的PCI-e插槽上，它与m.2走PCI-e通道的SSD差别不大，笔记本用户主要就看m.2接口的SSD就行了（主板上有该接口的情况下）</p>
</li>
<li><p><strong>不同的接口有什么差异？</strong><br>答：SATA3.0是目前最新的版本，是走SATA通道。最快也就6Gbps的速率。市面上的SATA盘最快也就550MB/s。而m.2走PCI-e通道的就还要分细一些。它还存在着通道和协议等方面的差距。m.2是一个接口，或者你可以叫它插槽，和SATA，mSATA（串口），IDE（并口）是同级别的。但m.2接口又细分为两种，一种是B key（又叫Socket2）。另一种是M key（又叫Socket3），两者因为接口金手指的缺口和针脚数不同而容易产生兼容性问题，大家可以去查一查其他资料看看两种m.2模组的外观有什么不同。而M.2和PCI-e的结合可以让SSD</p>
</li>
<li><strong>SATA和PCI-e总线标准有什么直观区别？</strong><br>答：我们熟悉的6Gbps的SATA接口是走SATA3.0的总线。速率顶天也就600MB/s，而有些m.2 SSD能达到2000MB/s多的速率，而这些SSD后面还经常伴随着PCI-e这个名词。而这里的PCI-e是一个和SATA3.0对应的另一个总线标准，或者叫其通道。现在市面上的一般是PCI-e3.0*4，一条PCI-e3.0能提供的带宽是8Gbps，乘以4后也就是32Gbps，最高4GB/s的传输速率，这可谓是大大得提高了原来SATA3.0只有600MB/s左右的巅峰速率。</li>
<li><strong>哪是不是所有的M.2 SSD的速率都是这么高呢？</strong><br>答：答案是否定的。我们先来理一下。之前说了m.2接口还分B key和M key不同的模组。而m.2仅是接口，也是可以走SATA总线的。在此文字都是乏力的，我们用如下图片进行讲解，相信一下就会觉得明白：<center>/<em>首先感谢一下帮我截这张大图的女生，嘻嘻</em>/</center><br><center><img src="/images/让电脑飞/m.2.png" alt="m.2"></center><br><center><em>所以就只有M.2走PCI-e 3.0</em>4的且支持NVme协议的SSD才能达到哦啊我们理想中的2GB/s以上的速率*</center></li>
<li><a name="masterControl"><strong>SSD的大脑–主控浅析</strong></a><br>解：简单的一句话，SSD的主控就和电脑的处理器一样重要，就像大脑一样负责着整个机体的运转。SSD主控的性能好坏直接影响到SSD的使用体验。主控芯片会负责合理调配各个不同的闪存芯片上的负荷，数据的中转，NAND颗粒的磨损平衡，还有ECC纠错，坏块映射，读写缓存（存内置缓存中，一般为DDR），垃圾回收，数据加密等操作，可谓是任务繁忙。所以我们在选择的时候就必须选一个不错的主控才行。而好的主控一般就只有一线品牌才会搭载。因此，我们在选择的时候千万不能图便宜去买一个没听过的杂牌，这类产品往往是价格相对较低，但是体验却和好的产品差别很大，<strong>所以我们应该去选择一线品牌来保证我们有一个优秀的体验，即使它贵一些也值。</strong></li>
<li><strong>▶（大知识点）SSD有使用寿命，那怎么使用才算科学？</strong><br>答：作为一个学生，大出血买一个SSD，真的希望它能用得越久越好，但是怎样才能让它用得久，怎样才知道自己的使用是不是科学的呢？其实就使用来说是特别复复杂的事情，因为每一个人的使用标准不同，这套使用方法或许换一个人就不适用了，都是见仁见智的事情。那么最有效的方法就是了解SSD内部关于存储这一块的知识。<br><strong>（1）擦写放大</strong><br>HDD(机械硬盘)的读写单位是扇区（Sector），一般大小为512KB。SSD的读写单位是页（Page），一般大小为4KB或8KB，但是SSD在进行擦除造作的时候，则是以块（Block）为单位，一个块通常是包含了128或者256个Page，那么一次擦除就是512KB或2MB（或其他值），假如说你要删除的文件不到512KB或者2MB，那么这一个完整的块当中的其他数据就会被这样的擦写给删除掉，那么为了避免这种逻辑上的错误，<strong>SSD的主控就会先把不删的数据转移到其他块当中，然后再执行删除之前的块，最后再把移动暂存的数据给移动回去（也有说法是不移回去）。</strong>于是乎这样一来，进行擦写时就会多擦写一些块，而造成擦写放大，增加SSD的擦写次数，增加损耗，减少其寿命。当然这也只是一个大概，类似于脏块的概念也还没有介绍，但我们可以明白一点的就是SSD的擦写，我们就知道对应着怎样去结合自己需求来科学使用了。<br><strong>（2） <a name="FTL">FTL</a>(Flash Translation Layer) 闪存转换层</strong><br>正因为SSD的每一个存储单元都有寿命可言，且其擦写和HDD有本质上的不同，但为了保障上层操作系统和文件系统的一致性，SSD的主控会来隐藏这一不同的处理过程的区别，让我们用SSD时和用HDD时感受不到差别，这就引入了FTL，闪存转换层。操作系统在读取文件时，会根据一张叫LBA的表去查询数据的地址，LBA（Logical Block Address）就是逻辑块地址，查询得到该数据在硬盘中的物理地址PBA（Physical Block Address）。很显然LBA到PBA的关系是一张映射表，就像警察要找你，首先去看一下翻一下LBA查到你家在哪，然后再去这个地址找你一个道理。但是由于固态每一个存储单元都是有寿命的，出于<a name="#WearBalance">磨损平衡（下一点会讲）</a>的需要，同一个LBA对应的PBA并不是固定的，这一张表一直处于变动中，让主控来处理动态关系，所以又提到了<a name="#masterControl">主控</a>，它的性能好坏真的很影响体验呀。<br><strong><a name="WearBalance">（3）磨损平衡</a></strong><br>磨损平衡也就是很多时候我们所看到其他文章中说的Wear Leveling。还是因为SSD的闪存颗粒的寿命，是以擦写次数来计算的，也就是P/E次数。如果数据就按照存储单元的物理地址递增的顺序来存储的话，那么前面的空间就会出现反复擦写的情况，这样就会造成前面这些空间有更多的擦写，就会更快的消耗完其寿命，这一片区域就损坏了。所以就需要引入磨损平衡的机制，也就是结合上一条写的<a name="#FTL">FTL</a>，对LBA和PBA进行科学的转化，保证所有的物理块的擦写（磨损）都能够被控制在一个大致相同的范围内。<br><strong>（4）垃圾回收 Garbage Collection(GC)</strong><br>以前我们用HDD的时候，应该都知道一个叫磁盘碎片整理的功能，但是这个功能对于SSD不适用，它会增加SSD的磨损。所以SSD需要一套新的机制，那就是垃圾回收，简称GC。其原理就是在SSD空闲的时候，全盘扫描有效的页并整理起来形成一个含有全部有效页的块，而那些无效页和块和页就被彻底清理了。而伴随这GC的另一个名词就是Trim，本质是一个ATA指令，作用在于让操作系统发出指令给SSD的主控，告诉它那些数据占用的地址是无效的，然后主控就会在这些地址上做一个标记，表面这里的数据是无用的。然后与GC配合后，就能在SSD进行GC时跳过这些这些无用的数据不被整理在一个有用的块当中，这样在节省时间的同时，也可以减少无用的写入，降低闪存的损耗，Trim本身并不能大幅改善SSD的性能，但是与GC协同工作后，却能达到事半功倍的效果，能让SSD在使用一段时间后依然能维持在一个不错的性能水平上。这也叫被动GC，有关主动GC方面的就暂时不讲了，不是所有的SSD都有主动GC，但都有被动GC。</li>
</ol>
<ul>
<li><strong>至此，5000字的长文就结束啦，如果真的要写SSD揭秘的话，或许可以写一本书，所以本文只是一个很简短而又精华的介绍，博主这一周多来，每天都用了些课余的时间给大家写这篇文章，在查阅资料的同时还站在读者的角度去思考，怎样才能写得更加明白，怎样才能在对SSD一无所知得情况下看懂。如果你真的希望自己了解SSD，那么你真的要每一句都认真阅读过，也不枉费我的良苦用心，希望朋友们都能够不花冤枉钱而买到自己最合适的产品。如果有任何问题，欢迎通过微博私信联系上我。</strong></li>
</ul>
<p><em>版权所有，转载请注明出处</em></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;SSD何方神圣？一探究竟&quot;&gt;&lt;a href=&quot;#SSD何方神圣？一探究竟&quot; class=&quot;headerlink&quot; title=&quot;SSD何方神圣？一探究竟&quot;&gt;&lt;/a&gt;&lt;center&gt;SSD何方神圣？一探究竟&lt;/center&gt;&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;认识好SSD的内在，几年不卡&lt;br&gt;我记得在我接触SSD初期的时候，就知道它的高性能和寿命特点，再加之这货很贵，我便觉得使用时不能马虎，万一盘挂了还不好做数据恢复，最重要的是这么贵的盘挂了，自己得多心疼啊。。。
    
    </summary>
    
      <category term="让电脑飞" scheme="http://shic.top/categories/%E8%AE%A9%E7%94%B5%E8%84%91%E9%A3%9E/"/>
    
    
      <category term="让电脑飞" scheme="http://shic.top/tags/%E8%AE%A9%E7%94%B5%E8%84%91%E9%A3%9E/"/>
    
  </entry>
  
  <entry>
    <title>百公里去眉山</title>
    <link href="http://shic.top/2017/09/17/RunTimeToMeishan/"/>
    <id>http://shic.top/2017/09/17/RunTimeToMeishan/</id>
    <published>2017-09-16T16:00:00.000Z</published>
    <updated>2017-09-17T11:34:46.175Z</updated>
    
    <content type="html"><![CDATA[<h2 id="山路漂移进眉山"><a href="#山路漂移进眉山" class="headerlink" title="山路漂移进眉山"></a><center>山路漂移进眉山</center></h2><p>2017年9月16日周六，我们按照原来约好的时间，汇集在一起准备去望鱼了，那地方的风景一般，但沿路上是时上时下的山路，当地政府还修的草油路，这样的山路骑车就会感觉特别爽。给我们飙车党一种深陷其中，无法自拔的体验，而在一个长上坡时，大腿都会发软，心想只要过来这个上坡，下面马上就会有一个下坡可以好好爽一把，因为车辆很少，我们自行车时速超50都没问题。路上我们放着音乐，特别带感，特别欢乐。途中放了一首初三时学校里经常放的歌，很有感触，让我想起了那个比现在还快乐许多的时光，歌中唱到了“爱拼才会赢”，正是对我们劳累后的鼓舞。<br><a id="more"></a></p>
<p><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=168620&auto=0&height=66"></iframe>    </p>
<ul>
<li>途中的风景一般，也没怎么停过，主要是飚车太爽了，哈哈哈    <center><img src="http://res.cloudinary.com/shi1996/image/upload/c_scale,h_720,w_960/v1505613959/IMG_20170916_120627_dmi2li.jpg" alt="wangyu"></center> </li>
<li>途经望鱼已是中午，我们吃饭后稍作休息冲了一哈壳子<center><img src="https://res.cloudinary.com/shi1996/image/upload/c_scale,h_960,w_691/v1505613954/IMG_20170916_132419_wfgrti.jpg" alt="Liaoqs"></center> </li>
<li>但昨天我们却再往前骑了一段，意外得来到了眉山洪雅境内，在交界处我们拍了一张纪念照。<center><img src="https://res.cloudinary.com/shi1996/image/upload/c_scale,h_960,w_720/v1505611420/三人合影_qdkyzz.jpg" alt="hongya"></center>    </li>
<li>但在这之后发现了不一样的美景，当然我们也是要上很多坡的，中途也是很累，骑着大腿乏力，屁股感觉要燃烧了一样，一直期盼着有一个下坡爽一爽，但没想到过了一个几百米的黑洞之后，呈现在眼前的景色却让我们大吃一惊，这种感觉特别棒，先上一张全景图图看看，可能有点大，但是效果应该特别棒<strong>:)</strong><center><img src="https://res.cloudinary.com/shi1996/image/upload/v1505614015/IMG_20170916_211335_d0kvq7.jpg" alt="yanvLack0"></center><br><center><img src="https://res.cloudinary.com/shi1996/image/upload/c_scale,h_1434,w_1917/v1505613967/IMG_20170916_151034_vo5pks.jpg" alt="yanvLack1"></center><br><center>(这里的水就很不一样，看旁边的介绍牌就说的是常年维持在国家Ⅱ类水质标准)</center><br><center><img src="https://res.cloudinary.com/shi1996/image/upload/c_scale,w_1920/v1505613975/IMG_20170916_152225_lu1lxs.jpg" alt="yanvLack2"></center><br><center>(和自行车一起拍照是不是有一种别样的风采)</center> </li>
<li>这还有一对新人在这里拍照，我们仨应该都祝福了他们吧，嘿嘿嘿<center><img src="https://res.cloudinary.com/shi1996/image/upload/c_scale,w_780/v1505613955/IMG_20170916_153535_ctilyb.jpg" alt="Wedding photos"></center></li>
<li>据说这湖泊叫雅女湖，雅女湖又称瓦屋山水库。地处四川省西沿的眉山市洪雅县瓦屋山森林公园境内。海拔高度达1080米。湖面积15平方公里，湖长19.04公里，湖宽13.31公里，水均深16米。库容6亿立方米，坝高为143米，来看一下地图上我们所处的位置就知道它有多大了<center><img src="https://res.cloudinary.com/shi1996/image/upload/c_scale,h_500/v1505619484/雅女湖_hwlzp2.png" alt="mapOfYanvLack"></center> 


</li>
</ul>
<ul>
<li>当然图片可能有些乏力，毕竟画幅没有达到一定要求是不能感受到像人眼看到的样子，那再放一个经过同学去掉了杂音的视频吧，嘻嘻<center><iframe height="498" width="510" src="http://player.youku.com/embed/XMzAyODMzMTExMg==" frameborder="0" 'allowfullscreen'=""></iframe></center></li>
<li>我们要准备离开的时候都已经15：40了，<strong>在聚雅女湖还有7公里那有一户人家淳朴热情，还为我们提前烧好了开水凉着等着我们回来饮用，缓解一下我们的疲劳，还为我们提供可口的黄瓜，让我们在他们那休息再出发。真的特别温暖，谢谢您带给了我们感动，最后挥手道别的“一路平安”一直温暖了之后的整个路程，是您的热情让这个美丽的地方更加迷人。</strong></li>
<li>我们与16点10多分的样子从好心阿姨家出发，又一次地跨过了交界处，骑陡坡累哭，下陡坡爽哭，中途有下雨我们也冒雨赶路，因为中途等一个骑得慢点的同学，所以回到学校时都已经19点。饥寒交迫的我们，便狼吞虎咽了起来，分分钟就。。。。<center><img src="https://res.cloudinary.com/shi1996/image/upload/c_scale,w_1080/v1505613974/eatDinner_xdbex4.jpg" alt="eatDinner"></center> </li>
<li>回到寝室楼下后，我们看了一下码表的数据，虽然很劳累，但却感到骄傲，我再一次打破了我们自己骑山路的数据，真的特别开心，特别感动<center><img src="https://res.cloudinary.com/shi1996/image/upload/c_scale,w_1200/v1505614977/speed2.0_cgmzpt.jpg" alt="speed"></center></li>
<li>想表达什么呢？我们以后再约～</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;山路漂移进眉山&quot;&gt;&lt;a href=&quot;#山路漂移进眉山&quot; class=&quot;headerlink&quot; title=&quot;山路漂移进眉山&quot;&gt;&lt;/a&gt;&lt;center&gt;山路漂移进眉山&lt;/center&gt;&lt;/h2&gt;&lt;p&gt;2017年9月16日周六，我们按照原来约好的时间，汇集在一起准备去望鱼了，那地方的风景一般，但沿路上是时上时下的山路，当地政府还修的草油路，这样的山路骑车就会感觉特别爽。给我们飙车党一种深陷其中，无法自拔的体验，而在一个长上坡时，大腿都会发软，心想只要过来这个上坡，下面马上就会有一个下坡可以好好爽一把，因为车辆很少，我们自行车时速超50都没问题。路上我们放着音乐，特别带感，特别欢乐。途中放了一首初三时学校里经常放的歌，很有感触，让我想起了那个比现在还快乐许多的时光，歌中唱到了“爱拼才会赢”，正是对我们劳累后的鼓舞。&lt;br&gt;
    
    </summary>
    
      <category term="漂移" scheme="http://shic.top/categories/%E6%BC%82%E7%A7%BB/"/>
    
    
      <category term="漂移" scheme="http://shic.top/tags/%E6%BC%82%E7%A7%BB/"/>
    
  </entry>
  
  <entry>
    <title>超强string类</title>
    <link href="http://shic.top/2017/08/31/C++string/"/>
    <id>http://shic.top/2017/08/31/C++string/</id>
    <published>2017-08-30T16:00:00.000Z</published>
    <updated>2017-08-31T13:40:41.287Z</updated>
    
    <content type="html"><![CDATA[<h2 id="C-里的string用得不爽怎么办"><a href="#C-里的string用得不爽怎么办" class="headerlink" title="C++里的string用得不爽怎么办"></a><center>C++里的string用得不爽怎么办</center></h2><p>还记得我20岁生日那天，上午帮一女生改代码，下午参加了一个编程活动，我选的语言是C++，然后，TMD居然装备忘带了。。。。晚上虽然和室友出去小搓了一顿，但心里还是惦记着我忘带的装备，没了信仰的加成，电脑都要蓝屏。。<br><a id="more"></a></p>
<ul>
<li>其实C++挺好的，我我一直很努力的学习，上马克思课我都在看，我觉得C++的编程书真的好看，特别是C++ Primer Plus 堪称C++界的巨著，奈何时间紧促，我老是想开发个规模大的东西，于是后面因为某些原因就入了JAVA的坑，但是面向对象的思想我在C++里却学到了很多。<br>我的装备好多都因为一次电脑硬件的变动而不见了，不知仍那去了，今天还找到了以前改的string类（基于某个初级版本），给它加了点料</li>
</ul>
<p><strong>string1.h</strong></p>
<pre><code>
/*这是一个增强（自己修改过的）string类，类名是String，可以实现直接用字符串复制给这个String类的对象
，还可以把这个类对象想字符数组一样输出第几个字符，还可以想正常的string类的对象一样的输出输入，做加法，
判断哪个长，变换大小写等运算使用时包含string1.h的头文件，并注意放的文件夹位置*/
//如果报错说strcpy等不安全就加这个：#define _CRT_SECURE_NO_WARNINGS//关闭安全检查
#ifndef STRING1_H_
#define STRING1_H_
#include <iostream>
#include<cctype>
using std::ostream;
using std::istream;
class String
{
private:
    char * str;             // pointer to string
    int len;                // length of string
    static int num_strings; // number of objects
    static const int CINLIM = 80;  // cin input limit
public:
    // constructors and other methods
    String(const char * s); // constructor
    String();               // default constructor
    String(const String &); // copy constructor
    ~String();              // destructor
    int length() const { return len; }
    // overloaded operator methods
    String & operator=(const String &); //重载 赋值运算符函数 对象赋对象
    String & operator=(const char *);     //重载 赋值运算符函数 字符串赋值对象
    String  operator+(const String &);   //重载+号
    char & operator[](int i);
    const char & operator[](int i) const;
    // overloaded operator friends
    friend bool operator<(const string="" &st,="" const="" &st2);="" friend="" bool="" operator="">(const String &st1, const String &st2);
    friend bool operator==(const String &st, const String &st2);
    friend ostream & operator<<(ostream &="" os,="" const="" string="" st);="" friend="" istream="" operator="">> (istream & is, String & st);
    // static function
    static int HowMany();
    //大小写转化，包含头文件 写：#include<cctype>
    void Stringlow();
    void Stringbig();
};
#endif
</cctype></(ostream></(const></cctype></iostream></code></pre>
--下面是方法实现

**string1.cpp**
<pre><code>
#include "string1.h"
#include <cstring>  // string.h for some
#include<cctype>
using std::cin;
using std::cout;
//有些用的strcpy，有些是strncpy。。反正都要报错说不安全

// initializing static class member

int String::num_strings = 0;

// static method
int String::HowMany()
{
    return num_strings;
}
// class methods
String::String(const char * s)     // construct String from C string
{
    len = std::strlen(s);          // set size
    str = new char[len + 1];       // allot storage
    std::strncpy(str, s, len + 1);           // initialize pointer
    num_strings++;                 // set object count
}

String::String()                   // default constructor
{
    len = 4;
    str = new char[1];
    str[0] = '\0';                 // default string
    num_strings++;
}

String::String(const String & st)
{
    num_strings++;             // handle static member update
    len = st.len;              // same length
    str = new char[len + 1];  // allot space
    std::strcpy(str, st.str);  // copy string to new location
}

String::~String()                     // necessary destructor
{
    --num_strings;                    // required
    delete[] str;                    // required
}

// overloaded operator methods

// assign a String to a String
String & String::operator=(const String & st)
{
    if (this == &st)
        return *this;
    delete[] str;
    len = st.len;
    str = new char[len + 1];
    std::strncpy(str, st.str, len + 1);
    return *this;
}

// assign a C string to a String
String & String::operator=(const char * s)
{
    delete[] str;
    len = std::strlen(s);
    str = new char[len + 1];
    std::strcpy(str, s);
    return *this;
}

String  String::operator+(const String &s)
{
    String sum;
    sum.len = len + s.len;
    sum.str = new char[sum.len + 1];
    std::strcpy(sum.str, str);
    std::strcat(sum.str, s.str);
    return sum;
}

// read-write char access for non-const String
char & String::operator[](int i)
{
    return str[i];
}

// read-only char access for const String
const char & String::operator[](int i) const
{
    return str[i];
}

// overloaded operator friends

bool operator<(const string="" &st1,="" const="" &st2)="" {="" return="" (std::strcmp(st1.str,="" st2.str)="" <="" 0);="" }="" bool="" operator="">(const String &st1, const String &st2)
{
    return st2 < st1;
}

bool operator==(const String &st1, const String &st2)
{
    return (std::strcmp(st1.str, st2.str) == 0);
}

// simple String output
ostream & operator<<(ostream &="" os,="" const="" string="" st)="" {="" os="" <<="" st.str;="" return="" os;="" }="" quick="" and="" dirty="" input="" istream="" operator="">> (istream & is, String & st)
{
    char temp[String::CINLIM];
    is.get(temp, String::CINLIM);
    if (is)
        st = temp;
    while (is && is.get() != '\n')
        continue;
    return is;
}
void String::Stringlow()
{
    for (int i = 0; i < len; i++)
    {
        str[i] = tolower(str[i]);
    }
    cout << "小写：" << str;
}  //变成小写

void String::Stringbig()
{
    for (int i = 0; i < len; i++)
    {
        str[i] = toupper(str[i]);
    }
    cout << "大写：" << str;
}  //变成大写
</(ostream></(const></cctype></cstring></code></pre> 

<p><em>哎，半年多没有看过C++了，友元函数，运算符重载，相关的垃圾回收机制都记忆模糊了，都不知找来的装备还能不能用了，关它的，先存个档~嘻嘻</em></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;C-里的string用得不爽怎么办&quot;&gt;&lt;a href=&quot;#C-里的string用得不爽怎么办&quot; class=&quot;headerlink&quot; title=&quot;C++里的string用得不爽怎么办&quot;&gt;&lt;/a&gt;&lt;center&gt;C++里的string用得不爽怎么办&lt;/center&gt;&lt;/h2&gt;&lt;p&gt;还记得我20岁生日那天，上午帮一女生改代码，下午参加了一个编程活动，我选的语言是C++，然后，TMD居然装备忘带了。。。。晚上虽然和室友出去小搓了一顿，但心里还是惦记着我忘带的装备，没了信仰的加成，电脑都要蓝屏。。&lt;br&gt;
    
    </summary>
    
      <category term="C++" scheme="http://shic.top/categories/C/"/>
    
    
      <category term="C++" scheme="http://shic.top/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>UEFI番外篇</title>
    <link href="http://shic.top/2017/08/27/UEFI2/"/>
    <id>http://shic.top/2017/08/27/UEFI2/</id>
    <published>2017-08-26T16:00:10.000Z</published>
    <updated>2017-08-27T01:28:15.439Z</updated>
    
    <content type="html"><![CDATA[<h2 id="改传统于UEFI，你知道这些就够了"><a href="#改传统于UEFI，你知道这些就够了" class="headerlink" title="改传统于UEFI，你知道这些就够了"></a><center>改传统于UEFI，你知道这些就够了</center></h2><p><em>在跟着上一篇改动了启动模式后是不是觉得UEFI很快呢，那么本篇就来简单讲讲UEFI和传统BIOS的一些区别以及为什么它要快些，作为一个Geek，光用肯定是不舒服吧，要弄清楚道理可能才是最好的</em><br><a id="more"></a><br>为了简单明了地弄懂这个问题，我通过自己的总结和举例，帮助读者懂明白。<br>虽然有些可能不是100%的准确，但大致可以这样理解。</p>
<ul>
<li><p></p><h4>UEFI采用的不同的开机引导</h4><br>首先我们明白，我们的系统是放在硬盘里的，那些数据是用一个容器来装着的，但硬盘里那么多的数据，计算机怎么知道开机需要哪一块的呢？所以开机的时候需要引导，像一个指挥棒一样，指引着硬件怎么去利用特定的数据。这里的引导模式就有些不同了，这在我们装系统的时候就能看出来，需要一个盘去引导硬件开机。<br><center><img src="/images/让电脑飞/引导.png" alt="引导"></center><br>传统的安装系统，在安装的时候会出现添加引导，其中你把系统装入的分区就是引导分区，如上图一样我把系统装在C盘，添加的引导就是C盘，且推荐也是C盘，意思是要用它来引导开机，而UEFI模式下，从装机时的引导就能看出不一样，需要的引导不是系统所在分区，而是我们建立的ESP分区了。如下图：<br><center><img src="/images/让电脑飞/UEFI引导.png" alt="UEFI引导"></center><br>我把系统装在C盘，但UEFI下的引导并不是C盘的，而是我们之前建立的ESP分区，就是上图所示的E盘。<strong>而从这里我们也明白了为什么要实现UEFI启动必须要有ESP分区了，还要向该分区里手动添加EFI分区文件，因为是需要用来ESP分区来引导系统的启动</strong>，而大家也会发现EFI分区文件和系统镜像文件里的boot文件夹里的EFI很像<p></p>
</li>
<li><p></p><h4>不同EFI文件夹里的不同内容</h4><p></p>
<center><img src="/images/让电脑飞/区别.png" alt="区别"></center><br><center>（上方为EFI分区文件，下方为win10iso里的efi文件夹，当然里面的内容是不同的）</center>   
</li>
<li><p></p><h4>UEFI和传统的BIOS启动方式不同</h4><br>我们推荐目前的电脑都采用UEFI启动是因为它开机快，为什么现在的UEFI比传统的BIOS启动快呢？原因还启动的流程不同<br>大概可以这样分：<strong>开机-&gt;UEFI初始化-&gt;引导操作系统-&gt;进入系统</strong><br>而传统模式下：<strong>开机-&gt;BIOS初始化-&gt;BIOS自检-&gt;引导操作系统-&gt;进入系统</strong><br>这么一来UEFI开机就要快些了。所以我们推荐使用UEFI，那么我们之前在改什么硬盘的分区结构又是怎么回事呢？为此我还专门去研究了一下硬盘的分区结构，那可以不改吗？答案是：不行的，必须改。我们需要安装Windows系统，<strong>由于微软的限制，只能将系统安装在GPT硬盘中</strong>。我们以前的传统模式下，BIOS是不能识别GPT的，所以那时我们的硬盘都是MBR的分区结构，这也有了<a href="http://shic.top/2017/08/25/UFEI1/" title="点击查看怎样UEFI启动">《怎样UEFI启动》</a>一文，里面有详细的处理步骤。而经过笔者的亲自测试，如果硬盘是MBR结构，即使使用UEFI版的装机U盘，也只能是传统的启动；如果硬盘是GPT结构的，安装win7会出现“Windows无法安装到这个磁盘,选中的磁盘采用GPT分区形式”，原因是win7没有像以后的系统一样预装efi文件。只有把硬盘格式改成MBR才可以装win7。所以给大家总结一下启动模式和硬盘的分区结构的组合搭配应该是：传统BIOS+MBR硬盘，或者UEFI+GPT硬盘。<p></p>
</li>
<li><p></p><h4>后言</h4><br>当然就后者UEFI+GPT硬盘，优势并不只是开机快了点，而UEFI有其他优势，GPT分区结构也有比MBR更强大的地方，因为已经超出了本文的讨论范围，所以就不赘述了。总的来说，<strong>在未来会有越来越多的UEFI+GPT的组合出现在电脑上，这应该是一个趋势所在</strong>。<p></p>
</li>
</ul>
<p><em>欢迎转载，转载注明出处</em></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;改传统于UEFI，你知道这些就够了&quot;&gt;&lt;a href=&quot;#改传统于UEFI，你知道这些就够了&quot; class=&quot;headerlink&quot; title=&quot;改传统于UEFI，你知道这些就够了&quot;&gt;&lt;/a&gt;&lt;center&gt;改传统于UEFI，你知道这些就够了&lt;/center&gt;&lt;/h2&gt;&lt;p&gt;&lt;em&gt;在跟着上一篇改动了启动模式后是不是觉得UEFI很快呢，那么本篇就来简单讲讲UEFI和传统BIOS的一些区别以及为什么它要快些，作为一个Geek，光用肯定是不舒服吧，要弄清楚道理可能才是最好的&lt;/em&gt;&lt;br&gt;
    
    </summary>
    
      <category term="让电脑飞" scheme="http://shic.top/categories/%E8%AE%A9%E7%94%B5%E8%84%91%E9%A3%9E/"/>
    
    
      <category term="让电脑飞" scheme="http://shic.top/tags/%E8%AE%A9%E7%94%B5%E8%84%91%E9%A3%9E/"/>
    
  </entry>
  
  <entry>
    <title>UEFI篇</title>
    <link href="http://shic.top/2017/08/25/UFEI1/"/>
    <id>http://shic.top/2017/08/25/UFEI1/</id>
    <published>2017-08-24T16:00:00.000Z</published>
    <updated>2017-08-26T02:56:15.500Z</updated>
    
    <content type="html"><![CDATA[<h2 id="电脑快速进入工作状态，你需要UEFI启动"><a href="#电脑快速进入工作状态，你需要UEFI启动" class="headerlink" title="电脑快速进入工作状态，你需要UEFI启动"></a><center>电脑快速进入工作状态，你需要UEFI启动</center></h2><p><em>首先要给大家讲一个故事，我朋友的原装win8.1笔记本，APU平台+机械硬盘，说实话那台属于低端产品，但每次开机都是12秒左右，老流氓就显示开机已完成，打败99%的电脑，这就是UEFI启动，不同与传统的BIOS。要是能让电脑更快，我绝对会去折腾。17年寒假的时候我真的去折腾了，把家里的电脑拿来连着重装了5，6次，最后一次才成的，前面都没有成功，于是就不断的查资料，不断的找原因，还去学习了一些硬盘的分区结构，最后才想了想才把它整理了出来形成了两篇文稿，如果你和我一样喜欢折腾，那就可以继续往下看了。</em><br><a id="more"></a><br>关于为什么UFEI启动这么快，下篇文章会简单说明一下，那么本篇我们就先来操作一番，先把电脑启动模式改成UEFI。</p>
<ul>
<li>首先我们要看一下我们电脑是否已经是UEFI启动了，如果是那就别看了。。。<br><center><img src="/images/让电脑飞/滴.jpg" alt="滴"></center><br><em>不对</em>，键盘win+R，调开运行，输入msinfo32，就会打开一个窗口，查看里面的BIOS模式就行了，写的UEFI，那么就是UEFI的的引导模式了。<br><center><img src="/images/让电脑飞/msinfo.png" alt="msinfo"></center><br>如果写的是传统，那就是传统的模式。这时，我们就需要把它改成UEFI，来达到电脑开机比以前快的目的。<br><center><img src="/images/让电脑飞/BIOS_model.png" alt="BIOS_model"></center><br>经过我的测试，不重装系统应该是行不通的。道理也很简单，那么这里再次为下一篇精彩的文章做出预告，欢迎及时关注《改传统于UEFI，你不得不知的这些》一文的更新，好了，废话不多说，我们现在就进行操作。<br>首先，我们做一件事需要一个规划，我们的操作要规划好，才能节约时间且达到满意的效果。首先我们的硬盘里是有重要的数据的，在进行改UEFI的过程中，需要更改硬盘的分区结构，涉及到所有的数据。当然这个在正常情况下是安全的，如果自己的电脑性能真的不好，运行软件容易卡顿，那就更加应该备份了，在运行过程中死机，那强行关机，多半会造成一些数据的损失。如果重要信息备份已经完成，或者没有可保留的数据，那么就往下看。</li>
</ul>
<ol>
<li>准备Windows系统</li>
<li>制作启动盘</li>
<li>修改磁盘分区方案</li>
<li>建立ESP分区</li>
<li>EFI分区操作</li>
<li>开始“刷机”    </li>
</ol>
<p>那么我们就开始分步开始操作了：</p>
<p></p><h4>准备Windows系统</h4><p></p>
<blockquote>
<p>重装系统先要准备好目标系统，在vista及之后的64位系统都支持UEFI，但是只有win8及之后的系统才预装了UEFI启动所需要的启动文件。如果还想用win7的朋友，就只能自行添加相关的EFI文件到系统包里面了。而就目前的形式来看，首先的系统当然是win10了。   </p>
</blockquote>
<center><img src="/images/让电脑飞/efi.png" alt="efi"></center><br>win8.1，efi文件夹里有boot文件里，里面还有相关的efi文件，8以后的系统都有它。<br><center><img src="/images/让电脑飞/efi1.png" alt="efi1"></center><br>Win7的efi文件夹里没有相应的boot文件夹，更没有efi的文件了，也就是没有预装efi文件。<br><br><h4>制作启动盘</h4><br>因为笔者喜欢用U盘装机，装机盘可以随时移动还可以外借，十分方便，所以本文就以U盘装机为例了。<br>大家在网上去搜索相关制作U盘启动盘的软件就行，此处记住，一定要下载UEFI装机版的软件。这些软件的使用在其官网上都有使用方法，笔者在这就不赘述了。<br>按照相关要求，把你要安装的系统放入制作好的U盘里。<br><br><h4>修改磁盘分区方案</h4><br>MBR和GPT是磁盘的两种不同分区方案，传统的启动模式下都是采用的MBR的分区结构，而因为微软限制，想要在UEFI下安装Windows系统只能将系统安装在GPT硬盘中，所以我们此处需要修改磁盘的分区方案。<br>而正好有软件可以让我们把磁盘无损地从MBR转到GPT，除非小概率事件自己机器出毛病卡死造成数据损失，其他时候都是安全的。那么我们就要用到一个名叫diskgenius的软件。如果你制作的U盘启动器里面有此软件，那么选择U盘启动后，在PE里操作。如果里面没有，就下载一个放U盘里，然后U盘启动后安装此软件。进入软件后，大家可以先把系统的分区表备份到U盘中，万一真的操作失败可以将备份分区表重新导入系统盘中。<br>我们点击软件顶部区域的“硬盘”，点击“转换分区表类型为GUID格式”。<br><center><img src="/images/让电脑飞/diskgenius.png" alt="diskgenius"></center><br><center>（点击确认即可）</center>    

<p></p><h4>建立ESP分区</h4><br>我们需要建立EFI system partition分区，这是UEFI GPT模式下必须有的分区，简称ESP分区。有些电脑上会有几百兆的隐藏空间，我们就把它删除了再建立ESP分区，如果电脑上没有这一小块的隐藏空间，那么就需要自己从C盘中分一点空间出来，当然强大的diskgenius可以完成此项任务。鼠标右键点击“调整分区大小”，设置100MB的分区大小就行了，然后选中刚分出来的区域（此时应该为灰色），建立ESP分区，如果是磁盘全部删除或者是新的磁盘，那么就会出现下面的画面<p></p>
<center><img src="/images/让电脑飞/esp.png" alt="esp"></center><br>选择建立ESP分区而不是MSR分区，设置大小为100MB即可，点击确定。如果磁盘是以前用过的，也没关系，照着上面步骤操作，<em>如果出来的界面和上面不一样，多半是因为以前硬盘引导过系统启动，该盘上已经有了MSR分区了，所以上图就不会出现，但会出现一个分区的详情选择，文件系统默认的可能是NTFS或者FAT32等，此处在选择单里面选择EFI system partition就行了，点击确定。盘符不用管</em>。有些玩家在操作的时候说此时一定不能分配盘符，要重新启动后再来分盘符，不然要出错，其实这里涉及到的4种情况笔者都亲自试过了，不管何时分配的盘符，都能成功装机，也有可能我用的diskgenius版本号是4.9的原因吧，大家看到这篇文章时，可能5.0都出来了，所以大家不用担心，大胆进行操作。<br><br><h4>EFI分区操作</h4><br>建立好ESP分区后，我们需要把EFI分区文件放入ESP分区更目录。此处我建立的ESP盘符是E<br><center><img src="/images/让电脑飞/efi2.png" alt="efi2"></center><br>然后再用UEFI引导修复工具修复，挂载ESP分区，选择要装系统的根目录<br><center><img src="/images/让电脑飞/uefi修复.png" alt="uefi修复"></center> 

<p></p><h4>开始“刷机”</h4><br>先进入BIOS，因为众多的主板设置不太相同，所以大家都根据这自己的情况来。<strong>在boot一项中选择启动模式，改成UEFI，或者有UEFI/Legacy字样的。保存退出。</strong> 再次进入BIOS，选择UEFI：U盘的启动，U盘可能会出现两个，<strong>要选择UEFI字样的</strong>，进入后按照标准装机步骤进行安装系统即可。<p></p>
<p><center><img src="/images/让电脑飞/efi3.png" alt="efi3"></center><br>装机完成后进入系统按照上述的查看方法查看启动方式，就已经修改了。</p>
<p><center><img src="/images/让电脑飞/efi4.png" alt="efi4"></center><br>接下来的日子里，你的电脑启动就会比以前快了。那么这个UEFI启动是不是很神奇呢，下一篇文章讲用通俗的语言来讲解一下这一原理，敬请期待吧~    </p>
<p><em>欢迎转载，转载注明出处</em></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;电脑快速进入工作状态，你需要UEFI启动&quot;&gt;&lt;a href=&quot;#电脑快速进入工作状态，你需要UEFI启动&quot; class=&quot;headerlink&quot; title=&quot;电脑快速进入工作状态，你需要UEFI启动&quot;&gt;&lt;/a&gt;&lt;center&gt;电脑快速进入工作状态，你需要UEFI启动&lt;/center&gt;&lt;/h2&gt;&lt;p&gt;&lt;em&gt;首先要给大家讲一个故事，我朋友的原装win8.1笔记本，APU平台+机械硬盘，说实话那台属于低端产品，但每次开机都是12秒左右，老流氓就显示开机已完成，打败99%的电脑，这就是UEFI启动，不同与传统的BIOS。要是能让电脑更快，我绝对会去折腾。17年寒假的时候我真的去折腾了，把家里的电脑拿来连着重装了5，6次，最后一次才成的，前面都没有成功，于是就不断的查资料，不断的找原因，还去学习了一些硬盘的分区结构，最后才想了想才把它整理了出来形成了两篇文稿，如果你和我一样喜欢折腾，那就可以继续往下看了。&lt;/em&gt;&lt;br&gt;
    
    </summary>
    
      <category term="让电脑飞" scheme="http://shic.top/categories/%E8%AE%A9%E7%94%B5%E8%84%91%E9%A3%9E/"/>
    
    
      <category term="让电脑飞" scheme="http://shic.top/tags/%E8%AE%A9%E7%94%B5%E8%84%91%E9%A3%9E/"/>
    
  </entry>
  
  <entry>
    <title>准备起飞之SSD</title>
    <link href="http://shic.top/2017/08/23/SSD%E8%A1%8C%E6%83%85%E6%B5%85%E6%9E%90/"/>
    <id>http://shic.top/2017/08/23/SSD行情浅析/</id>
    <published>2017-08-22T16:00:00.000Z</published>
    <updated>2017-08-23T03:01:18.471Z</updated>
    
    <content type="html"><![CDATA[<h2 id="涨价风波一年多的SSD行情浅析"><a href="#涨价风波一年多的SSD行情浅析" class="headerlink" title="涨价风波一年多的SSD行情浅析"></a><center>涨价风波一年多的SSD行情浅析</center></h2><p>希望能帮到正要买固态的你<br><a href="http://shic.top" title="你点呀！">shic.top</a>   防哈橙戌员</p>
<ul>
<li><strong>简介</strong>：SSD全称是<em>Solid State Drive/Disk</em>，顾名思义意为<em>固态硬盘</em>，不同于机械硬盘，它没有驱动旋转马达，没有磁盘碟片，用NAND闪存颗粒作为存储介质，是一个常见的非易失性存储。且SSD内部还有包括想主控，缓存等东西。<a id="more"></a>
<blockquote>
<p>我记得固态硬盘从去年第二季度经历了一次白菜价后，价格就一直处于上升阶段，涨到现在都还在涨，就只有2017年5月左右有一些小幅度价格平缓时期。那是不是价格一直这么涨，是不是现在就不是买的时候呢？情况获取还不是这样的，你在现在依然可以有选择。那么我们先来看一下SSD的主要两个涨价因素：</p>
<blockquote>
<p>1.各大闪存颗粒厂商颗粒正处于2D NAND转3D NAND中。<br> 2.移动市场需求火热，eMMC，UFS等都是NAND的闪存颗粒。<br> //3.当然也有主流厂商的抬价</p>
</blockquote>
</blockquote>
</li>
</ul>
<p>的确，从现在的行情来看，固态的价格涨了太多了，一年多钱399能买一个一线大厂的240GB盘，现在可能需要600多，看似也不适合出手了，而且就目前形势来看，固态的需求依然旺盛，厂商依然还在产能转型期，所以固态预计的价格平缓和降价至少会在18年Q1，但可以确定的是，短时间不会回到16年上半年的白菜价了。<br>简单的分析一下哪些情况可以买：</p>
<ol>
<li>你的电脑有m.2接口</li>
<li>电脑真的太慢需要出血购买</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line">1.对于第一点来说，m.2接口初期都是配合一些高端产品在出售，这类固态通常是走PCI-E通道，走SATA通道的另当别论，这类产品本身就处于高端产品，但在涨价风波中却没有</div><div class="line">过多的上涨，而且因为新技术的普及。整体还有所下降，甚至和涨价后的有些SATA接口的产品一个价位了，这样一来，性能高出好几倍的PCI-E通道的固态是不是就值了呢</div><div class="line">*/</div></pre></td></tr></table></figure>
<ul>
<li>注：有m.2接口且支持PCI-E通道电脑的一定要配同样是走PCI-E的SSD，传统的硬盘接口SATA，全称是<em>Serial Advanced Technology Attachment</em>，是一种串行电脑总线，专为机械硬盘而设计的AHCI标准配合SATA接口并不能发挥出固态的全部实力，甚至因为接口性能而出现了速度瓶颈，AHIC+SATA并不适合低延迟的固态，全新的NVMe协议的PCI-E固态才是正确的选择，NVMe是Non-Volatile Memory Express的缩写，非易失性存储器标准，充分利用PCI-E通道的低延时以及并行性，降低了I/O操作等待时间、提升同一时间内的操作数、更大容量的操作队列等。性能可谓是突飞猛进</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line">2.你的电脑真的太卡了，已经影响到自己的使用体验了，那么对于没有m.2接口的电脑，选择就2条原则，第一就是选国际一线品牌，有保障，固态硬盘是有使用寿命的。</div><div class="line">  第二就是相同价格选MLC颗粒而不是TLC。</div><div class="line">*/</div></pre></td></tr></table></figure>
<p><em><center>好了，不多说了，这只是简单的分析，后期还会给大家分享关于固态装机和后期使用的一些很重要的事，敬请期待吧</center></em></p>
<center><img src="/images/让电脑飞/战术目镜.jpg" alt="战术目镜"></center>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;涨价风波一年多的SSD行情浅析&quot;&gt;&lt;a href=&quot;#涨价风波一年多的SSD行情浅析&quot; class=&quot;headerlink&quot; title=&quot;涨价风波一年多的SSD行情浅析&quot;&gt;&lt;/a&gt;&lt;center&gt;涨价风波一年多的SSD行情浅析&lt;/center&gt;&lt;/h2&gt;&lt;p&gt;希望能帮到正要买固态的你&lt;br&gt;&lt;a href=&quot;http://shic.top&quot; title=&quot;你点呀！&quot;&gt;shic.top&lt;/a&gt;   防哈橙戌员&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;简介&lt;/strong&gt;：SSD全称是&lt;em&gt;Solid State Drive/Disk&lt;/em&gt;，顾名思义意为&lt;em&gt;固态硬盘&lt;/em&gt;，不同于机械硬盘，它没有驱动旋转马达，没有磁盘碟片，用NAND闪存颗粒作为存储介质，是一个常见的非易失性存储。且SSD内部还有包括想主控，缓存等东西。
    
    </summary>
    
      <category term="让电脑飞" scheme="http://shic.top/categories/%E8%AE%A9%E7%94%B5%E8%84%91%E9%A3%9E/"/>
    
    
      <category term="让电脑飞" scheme="http://shic.top/tags/%E8%AE%A9%E7%94%B5%E8%84%91%E9%A3%9E/"/>
    
  </entry>
  
  <entry>
    <title>让电脑飞系列开篇</title>
    <link href="http://shic.top/2017/08/22/%E8%AE%A9%E7%94%B5%E8%84%91%E9%A3%9E%E5%89%8D%E8%A8%80/"/>
    <id>http://shic.top/2017/08/22/让电脑飞前言/</id>
    <published>2017-08-21T16:01:00.000Z</published>
    <updated>2017-08-23T02:52:54.298Z</updated>
    
    <content type="html"><![CDATA[<h2 id="电脑怎么飞"><a href="#电脑怎么飞" class="headerlink" title="电脑怎么飞"></a><center>电脑怎么飞</center></h2><p><code>作者：防哈橙戌员</code> 主页：<a href="http://shic.top" title="你点呀！">shic.top</a></p>
<p><strong>说实在的，玩机这么久了，也是时候答应小伙伴的要求了，相应你们的号召，先解决一下电脑使用的问题，还你一个高效快速的体验，我也省点心不必每次自己操作，大家去<em>我的主页<a href="http://shic.top" title="没错，这就是我的主页">shic.top</a></em>看<em>让电脑飞</em>相关标签的的帖子，保证你上了这趟车车再也回不去了</strong></p>
<a id="more"></a>
<center><img src="/images/让电脑飞/电脑飞开车.jpg" alt="秋名山车神" title="秋名山车神"></center><br><center>会是这样的吗？ </center>   

<p>哈哈，开玩笑啦，首先我们就需要了解两个东西</p>
<ul>
<li>固态硬盘<blockquote>
<p>英文名SSD，在磁盘界是秒天秒地秒空气的存在，特别是现在走PCI-E3.0通道的盘，相信大家都对它很有关注</p>
</blockquote>
</li>
<li>UEFI<blockquote>
<p>UEFI全称是<em>Unified Extensible Firmware Interface</em>，也就是<strong>统一的可扩展固件接口</strong>的意思，可以说是近几年里要取代电脑传统启动方式BIOS的节奏了</p>
</blockquote>
</li>
</ul>
<p>看到这里是不是觉得很糊涂了呢，没关系，这还没开始讲嘛，即将发布的教程没什么难度，你只需要动手去跟着操作就行了，没什么看不懂的，要勇于去实践，去探索，去尝试，折腾了半天成功后，你也会有一种满满的自豪感，到时候你就知道电脑开机比电视还快有多爽了，是的，真的</p>
<h2 id="很爽！！"><a href="#很爽！！" class="headerlink" title="很爽！！"></a><center>很爽！！</center></h2><center>期待噢，等我更新噢~</center><br><center><img src="/images/让电脑飞/会心一笑.jpg" alt="会心一笑" title="会心一笑"></center>

]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;电脑怎么飞&quot;&gt;&lt;a href=&quot;#电脑怎么飞&quot; class=&quot;headerlink&quot; title=&quot;电脑怎么飞&quot;&gt;&lt;/a&gt;&lt;center&gt;电脑怎么飞&lt;/center&gt;&lt;/h2&gt;&lt;p&gt;&lt;code&gt;作者：防哈橙戌员&lt;/code&gt; 主页：&lt;a href=&quot;http://shic.top&quot; title=&quot;你点呀！&quot;&gt;shic.top&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;说实在的，玩机这么久了，也是时候答应小伙伴的要求了，相应你们的号召，先解决一下电脑使用的问题，还你一个高效快速的体验，我也省点心不必每次自己操作，大家去&lt;em&gt;我的主页&lt;a href=&quot;http://shic.top&quot; title=&quot;没错，这就是我的主页&quot;&gt;shic.top&lt;/a&gt;&lt;/em&gt;看&lt;em&gt;让电脑飞&lt;/em&gt;相关标签的的帖子，保证你上了这趟车车再也回不去了&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="让电脑飞" scheme="http://shic.top/categories/%E8%AE%A9%E7%94%B5%E8%84%91%E9%A3%9E/"/>
    
    
      <category term="让电脑飞" scheme="http://shic.top/tags/%E8%AE%A9%E7%94%B5%E8%84%91%E9%A3%9E/"/>
    
  </entry>
  
  <entry>
    <title>关于本站</title>
    <link href="http://shic.top/2017/08/22/aboutSite/"/>
    <id>http://shic.top/2017/08/22/aboutSite/</id>
    <published>2017-08-21T16:00:00.000Z</published>
    <updated>2017-08-23T02:52:54.282Z</updated>
    
    <content type="html"><![CDATA[<center><img src="/images/aboutThisSite.jpg" alt="关于" title="关于"></center>

<h2 id="为什么有本站"><a href="#为什么有本站" class="headerlink" title="为什么有本站"></a><center>为什么有本站</center></h2><blockquote>
<p>首先给大家讲一个故事，从前有两个程序员在聊天，A：“我昨天碰到个妹子找我，说是电脑出问题了，我觉得肯定不是只修个电脑这么简单，然后……”，B：“什么？她电脑CPU是什么型号的？”。。。很显然重点不是在CPU型号上。但有时候想想，电脑的这些配置，还真的是我们这一群人可以讨论一天的话题，虽说会修电脑的程序员应该是很少的，在我的同学中，对电脑的这些配置也了解很少，因为我们都不是学维修的，也不会学很多硬件上的东西，大多数还是软件，涉及到编程写代码。</p>
<blockquote>
<p><a id="more"></a>而我是那种对于电脑的基础部件很有兴趣的人，所以经常折腾电脑，玩儿久了也有不少的体会，也可以叫做一个小小的极客吧。借着暑假的空闲时间，简单上线了一个博客平台，分享一些关于电脑日常使用和优化的帖子，让大家也能有一个反应快速的生产力工具，提高自己的工作学习效率，这也算是我的一个课外兴趣吧，捣鼓了大半天，研究了一个啥好用的技能，能够通过自己的平台进行分享也是很有乐趣的一件事，毕竟兴趣能冲淡无聊而无线重复的平凡生活，让我们更加有活力。      </p>
<blockquote>
<p>本站也只是笔者的一个课外兴趣，也不做过多的修饰和更改，仅仅是一个个人博客，由于<strong>不可抗拒的原因（自己以后可能会把该博客搬到国内，也许不会，因为歪果有些云服务器的确便宜，以后搬回来再备案、所以目前暂不添加评论功能了）</strong>，以后有时间可能会多一个分类，就不光是计算机的东西，我会根据实际的情况和时间节点来给大家分享一些计算机方面的知识，希望能够帮到你，如有什么问题，还可以微博私信我，每一期的文章分享我也会在微博上及时更新，希望它能够第一时间和你见面，下面的 就是我的微博，赶快加一波关注吧～    </p>
</blockquote>
</blockquote>
</blockquote>
<center><img src="/images/weibo.jpg" alt="微博" title="微博关注"></center>]]></content>
    
    <summary type="html">
    
      &lt;center&gt;&lt;img src=&quot;/images/aboutThisSite.jpg&quot; alt=&quot;关于&quot; title=&quot;关于&quot;&gt;&lt;/center&gt;

&lt;h2 id=&quot;为什么有本站&quot;&gt;&lt;a href=&quot;#为什么有本站&quot; class=&quot;headerlink&quot; title=&quot;为什么有本站&quot;&gt;&lt;/a&gt;&lt;center&gt;为什么有本站&lt;/center&gt;&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;首先给大家讲一个故事，从前有两个程序员在聊天，A：“我昨天碰到个妹子找我，说是电脑出问题了，我觉得肯定不是只修个电脑这么简单，然后……”，B：“什么？她电脑CPU是什么型号的？”。。。很显然重点不是在CPU型号上。但有时候想想，电脑的这些配置，还真的是我们这一群人可以讨论一天的话题，虽说会修电脑的程序员应该是很少的，在我的同学中，对电脑的这些配置也了解很少，因为我们都不是学维修的，也不会学很多硬件上的东西，大多数还是软件，涉及到编程写代码。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;
    
    </summary>
    
      <category term="IntelliJ IDEA" scheme="http://shic.top/categories/IntelliJ-IDEA/"/>
    
    
      <category term="IntelliJ IDEA" scheme="http://shic.top/tags/IntelliJ-IDEA/"/>
    
  </entry>
  
</feed>
