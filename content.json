{"meta":{"title":"GeekShi","subtitle":null,"description":"这是shic的博客，你能了解到一些电脑的技巧和编程的小知识","author":"this.Shi","url":"http://shic.top"},"pages":[{"title":"","date":"2017-10-11T10:35:22.253Z","updated":"2017-10-11T10:35:22.240Z","comments":true,"path":"404.html","permalink":"http://shic.top/404.html","excerpt":"","text":"一个超小的404页面"}],"posts":[{"title":"关于Java Web的小呆萌","slug":"smallDemoAboutJavaWeb","date":"2017-11-18T16:00:00.000Z","updated":"2017-11-19T06:49:54.921Z","comments":true,"path":"2017/11/19/smallDemoAboutJavaWeb/","link":"","permalink":"http://shic.top/2017/11/19/smallDemoAboutJavaWeb/","excerpt":"login-demo power by spring boot 目的 Java web是目前很火的一个方向，大量的计算机专业的同学都在学习它，而其中最重要的开发框架就是Spring","text":"login-demo power by spring boot 目的 Java web是目前很火的一个方向，大量的计算机专业的同学都在学习它，而其中最重要的开发框架就是Spring。而Spring Boot是当前Spring生态当中的一个新生力量，有着颠覆Java web开发的趋势。可谓是形式大好。而目前市面上的教程较少，很多也不能直接给同学们讲解清楚，所以作为钻研过该技术的我们，深知它的强大，希望用一种最有效的方式，想大家介绍一下它，感受一下Java web开发的魅力。 本次视频以一个用户登录注册的例子来进行讲解，搭建好开发的基础骨架，有利于同学们的后续学习和研究。在此基础上进行开发就会变得特别简单而不用为很多不懂的东西烦恼。 由于没有写过稿子直接讲解和录制的，所以难免在会有点语误，还希望大家理解 发车(建议在电脑端观看，点击高清画质效果会好些,密码是password。优酷竟然要放广告，大家见谅。。) 总结 关于这个小栗子的源代码我已经放在github上面了，需要就点击Fork,尽管checkout，要是觉得不错还可以Star哦。点击获取","categories":[{"name":"IntelliJ IDEA","slug":"IntelliJ-IDEA","permalink":"http://shic.top/categories/IntelliJ-IDEA/"},{"name":"Spring Boot","slug":"IntelliJ-IDEA/Spring-Boot","permalink":"http://shic.top/categories/IntelliJ-IDEA/Spring-Boot/"}],"tags":[{"name":"IntelliJ IDEA","slug":"IntelliJ-IDEA","permalink":"http://shic.top/tags/IntelliJ-IDEA/"},{"name":"Spring Boot","slug":"Spring-Boot","permalink":"http://shic.top/tags/Spring-Boot/"}]},{"title":"Model与ModelMap","slug":"FrontAndBackInteraction","date":"2017-10-28T16:00:10.000Z","updated":"2017-10-30T10:54:42.147Z","comments":true,"path":"2017/10/29/FrontAndBackInteraction/","link":"","permalink":"http://shic.top/2017/10/29/FrontAndBackInteraction/","excerpt":"前后端交互Model与ModelMap 看名字感觉ModelMap要能存很多东西，而Model莫非只能存一个属性？ 然而实验了一下，Model也能存多个属性进去。。 那ModelMap是怎么个用法。。。//待实验，待去查看类地源码","text":"前后端交互Model与ModelMap 看名字感觉ModelMap要能存很多东西，而Model莫非只能存一个属性？ 然而实验了一下，Model也能存多个属性进去。。 那ModelMap是怎么个用法。。。//待实验，待去查看类地源码 Model里面到底存的什么？ 示例：model.toString():{user=User{id=2, username=&#39;shi&#39;, password=&#39;shi&#39;},ModelTest=User{id=null, username=&#39;ModelTest&#39;, password=&#39;hasAnotherAttr?&#39;}}，Model里面就直接放的是整个对象，Model相当于一个容器 怎么删除Model里的数据 首先要明白的就是Model里同名的属性就只有一个，那么直接覆盖它，让它等于某个值我们就知道它是否被删除了，这一点应该是行得通的 那么直接让他等于null，会报错，很巧妙的解决办法就是new一个新的对象，没有初值的，那它里面该对象的数据成员的值就是空的了，也是一个特殊值null，很方便进行判断是都删除了Model中的该属性了 由一个问题引起的问题：.怎么让一个action返回一个url，然后进入另一个action 重定向就行，redirect:/url，然而重定向后，model里的值就没有了 然后问题就来了，Model里的值 怎么回事？？ Action交由另一个Action处理后传值的问题研究一：发现问题后台报错，说的admin.loginName为空，模板的渲染就要出错，我是在第一个action里往model里存了admin的，但为什么为空？ 二：去实验，寻找问题的根源 在不同的action处理方法里打印其model，也就是输出model.toString()的值，发现存入model的值就只限于在一个方法中处理了就往前端传的时候才存在，要是跳转了第二个方法，那model就不是同一个model了，自然里面的存的东西也就不一样，这是结论一 经过和一个朋友的交流，发现不光是spring boot里的model在重定向后会出现这种情况，springMVC也是，然后需要用到转发才能将参数一并传过去，这让我想起了以前学jsp和servlet的时候，的确有这种情况 在网上找收spring boot的转发，出来了基本都是springMVC的东西。。。于是看了一下，重定向也是用的redirect，于是大胆猜测转发也是一样的，都是forward 尝试forward，的确是正确的转发return “forward:/url”;，但是访问的时候，控制台说的request method post is not support。。。反正这个问题没有解决，于是把这两个action都改成了@PostMapping，然后又说get方法也不被支持。 网上有说法是，要redirect+url+参数，就是手动拼接，或者是用到一个叫RedirectAttributes的类，点击该类进行查看可以看出，该类也是继承了之前我们提到的Model的，敲出来看了看，这个类肯定也有类似于加入某些参数的方法，毕竟继承了Model，于是又去实验RedirectAttributes RedirectAttributeshench很扯的地方就是，它和Model都报存同一个东西，Model能全部打印出来，而RedirectAttributes只能打印出报存内容的id值，就是一串id值，20个，而Model打印出流程20个对象，这也解释了为什么在代码编写正确的情况下，前端还是没有正确接收到来自后台的参数，又有一个很神奇的就是，RedirectAttributes里面存的admin对象，控制台打印出来的是空，但是前端又能正确访问到。。三：综其上实验，得出究极解决方案:) 由于两个处理方法都要接收参数，于是都用l@PostMapping，第一个controller处理方法里传入前端来值，附带上RedirectAttributes redirectAttributes, BindingResult bindingResult两个参数，处理后将某一值存入，例如：redirectAttributes.addAttribute(“admin”,admin);然后return “forward:/url”; 在第二个controller处理方法的参数里，加上Model model，再加上前一个方法存入redirectAttributes中的参数，这里是@alid Admin admin，还有错误提示参数。此处的参数列表是：Model model ,@Valid Admin admin,BindingResult bindingResult 在第二个方法中传入的admin对象就是在第一个方法中存入redirectAttributes中的那个Admin对象。这里传入Model对象，就是为了把再该方法中处理了的参数存入Model对象中，并在前端进行方法，这样最终做成了。解决了困扰我一天半的难题，还花了一个小时来写总结和博客。 以上问题是：登录-&gt;AdminController里的@PostMapping(“/login”)-&gt;正确时返回的正确视图是forward:/adminIndex（这个转发的处理类是NewsinfoController）-&gt;显示登录后的主页（能查看自己的信息，目前最新的20条信息）-&gt;然后点击添加通知后-&gt;发现新的页面里，管理员用户的信息又没有了。。。于是又开始了为期一天半的探究 多action多页面跳转研究一：发现问题之前用了RedirectAttributes来存放参数，但多跳转几次就没有用了。。。感觉之前花了一天半玩儿了那么多还是被坑了啊:( 二：又去实验，寻找问题的根源，然后在一天半后得出了看似比较终极的答案 废话还是少说了，我搜了很多怎么样在整个项目中都可以访问到某些值，于是一个关键词出现在了我的视野里Session，然后session怎么用呢？ 之前说要加上什么artifactId为spring-session包，还要加artifactId为spring-boot-starter-redis的包，然后再配置文件里加redis相关的配置，再在处理方法中加上HttpSession类，于是就报错了，真的是实验了很久，于是又改了回来，处理方法里的参数重新换回了Model，但是还是报错，和以前一样，说的是Session创建失败，以前都是这样操作的一样的处理和渲染，但是现在却要报错，想来想去后决定把所有东西都恢复到以前，才发现pom里又session的包就要出错，yml配置文件里也要删除干净。 于是我在处理方法中加上了最普通的HttpSession的参数(javax.servlet.http.HttpSession)，什么依赖都没有加，于是还成了。。 当然要使用好HttpSession还是需要配合Model来使用的 a标签传参数 &lt;a th:href=&quot;@{&#39;/delete/&#39;+${thisNewsinfo.id}}&quot;&gt;删除&lt;/a&gt;例如这样，这是一个相对路径写法，${thisNewsinfo.id}从从Model里面得到一个值，然后向字符串拼接一样接在url后面，比如/delete/105，就是传递的105参数到后台 处理方法上一定要加的是Get请求参数，例如：@GetMapping(&quot;/delete/{id}&quot;) 参数列表里加上@PathVariable(&quot;id&quot;) Integer id，然后就能直接使用该id变量了。","categories":[{"name":"IntelliJ IDEA","slug":"IntelliJ-IDEA","permalink":"http://shic.top/categories/IntelliJ-IDEA/"},{"name":"Spring Boot","slug":"IntelliJ-IDEA/Spring-Boot","permalink":"http://shic.top/categories/IntelliJ-IDEA/Spring-Boot/"}],"tags":[{"name":"IntelliJ IDEA","slug":"IntelliJ-IDEA","permalink":"http://shic.top/tags/IntelliJ-IDEA/"},{"name":"Spring Boot","slug":"Spring-Boot","permalink":"http://shic.top/tags/Spring-Boot/"}]},{"title":"争取写一个就我能看懂的笔记 嘻嘻～","slug":"FullStackDevelopment","date":"2017-10-28T16:00:00.000Z","updated":"2017-10-29T13:07:37.759Z","comments":true,"path":"2017/10/29/FullStackDevelopment/","link":"","permalink":"http://shic.top/2017/10/29/FullStackDevelopment/","excerpt":"Full Stack Development with Spring Boot环境 Windows 10 64Bit 1703Pro JDK 1.8 IntelliJ IDEA 2017.1.1 Maven 3.5 MySQL 5.5 Spring Boot 1.5.7.RELEASE","text":"Full Stack Development with Spring Boot环境 Windows 10 64Bit 1703Pro JDK 1.8 IntelliJ IDEA 2017.1.1 Maven 3.5 MySQL 5.5 Spring Boot 1.5.7.RELEASE 创建 打开IntelliJ-&gt;New Project-&gt;Spring Initializr-&gt;[正确输出GroupID，Artifact等参数,此处选择的jar方式]-&gt;为项目添加依赖(此处选择web即可，之后的框架可以通过手动添加pom文件的方式，或者直接点击之后就不用之后在pom里写了)-&gt;点击next，点击Finlishi完成项目的创建 给pom.xml手动添加以依赖(此处分享一下我自己添加的依赖，是可以共用的，只是dependency) 1234567891011121314151617181920212223242526&lt;!-- 包含jpa，mysql驱动，hibernate-entitymanager，thymeleaf模板库 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.hibernate&lt;/groupId&gt; &lt;artifactId&gt;hibernate-entitymanager&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-websocket&lt;/artifactId&gt; &lt;version&gt;1.5.6.RELEASE&lt;/version&gt; &lt;/dependency&gt; 修改spring配置文件application.properties(建议改成application.yml) 1234567891011121314151617spring: datasource: driver-class-name: com.mysql.jdbc.Driver url: jdbc:mysql://127.0.0.1:3306/[your db] username: [your username] password: [your password] thymeleaf: encoding: utf-8 cache: false #关闭缓存，不然没法看见实时页面？ mode: HTML5 content-type: text/html jpa: hibernate: ddl-auto: update[create/...] show-sql: true 实体类映射表 写实体类反向建立数据表（top.shic.domain/entity） @Entity 对整个类进行实体类注解 @Id和@GeneratedValue 用于主键id的注解 对于其他字段用到@Column(length = [?],nullable = false),还有其他属性 对于某些数字的控制，注解@Min(value = 18,message = “未成年不得入内”) 对于某些字符串长度的控制 @Size(min=2, max=30) 不能为空，并写出错误时的提示 @NotNull(message = “该字段不能缺”) 测试运行，查看数据库是否正确生成了实体类表 Repository层 接口： Repository 空接口 CrudRepository 继承Repository，实现CRUD PagingAndSortingRepository 继承CrudRepository，实现分页和排序相关的方法 JpaRepository 继承PagingAndSortingRepository，实现JPA规范相关的方法 定义查询方法 使用Repository中定义过规范格式的方法名进行查询 在方法体上，使用注解@Query([？查询条件？]) @Query只能进行查询操作，要进行删除和更新操作就必须使用到另外两个注解，@Modifying和@Transactional @Modifying写在@Query上面，@Transactional写在服务层（下一大点会讲） 特别注意两点： 在测试类前不写@RunWith(SpringRunner.class)和@SpringBootTest就会报空指针的错误 @Modifying的注解只能返回void，int，和Integer类型的返回值，成功修改就返回1（错误时，推测是0），可能就只能判断是否正确修改了。如果返回类型是其他的话就要报错。 Service层service层通常是放一些对数据库进行更改和删除的操作，之前测试的Repository层的一些功能测试比如说保存，添加等，在正式编码时就可以把操作的方法写在service层 Service层的类前加@Service注解 在方法前加@Transactional，//这里的注解是javax.transaction.Transactional Service层注入Repository层的对象，然后在@Transactional事务管理所注释的方法里调用Repository层的方法进行数据库操作。 测试：RepositoryTest 测试类前添加@RunWith(SpringRunner.class)和@SpringBootTest注解 @Autowired自动注入Repository层对象 测试方法前添加@Test注解 测试：ServiceTest 测试类前添加@RunWith(SpringRunner.class)和@SpringBootTest注解 @Autowired自动注入Service层对象 测试方法前添加@Test注解 Controller层 在Controller层调用Service层的方法进行业务逻辑的控制 @RestController和@Controller的区别 @RestController添加到类前后，直接在方法体上添加访问路径的注解 @Controller在做后端访问控制时有点区别，详情请点击 什么情况下需要对同一个url同时编写@GetMapping和@PostMapping： 例如：当需要登录的时候，访问/login时，如果只有post模式，那我第一次直接访问需要进入页面进行登录的时候是不是就直接通过post把参数传给处理方法了，而此时我并没有输出任何参数也不是通过post方法进行访问的，所以后台会报错。 解决方法1：那么我们就对同一个url，比如这里的/login同时进行@GetMapping和@PostMapping的方法编写，保证在第一次访问登录表单时不是直接将结果传回给给服务器而时请求一个页面，这是一个逻辑问题！ 解决方法2：请求登录表单时用&quot;/login&quot;，控制方法注解为@GetMapping，登录表单中的&lt;form&gt;标签的提交url就换一个，比如说”/toLogin”，然后用post模式，这样就区分开了到底是请求页面还是提交参数了 在做和前端交互时需要用到@Controller，并使该类继承WebMvcConfigurerAdapter类 重写一个方法addViewControllers(ViewControllerRegistry registry) 处理方法前用注释标标注，传参时： 单独参数：参数前加@RequestParam(“前端参数名字”)，id用(主键?)用@PathVariable(“id”) 对象参数：@Valid 需要向前端进行传值时加上Model model 参数 参数中加上BindingResult类对象bindingResult，进行错误严重，if(bindingResult.hasErrors())，就进行错误处理 方法返回一个字符串，官方定义是取点”.html”字样的模板文件名，用来匹配要想客户端显示的内容 后台要向前端传值，在方法参数里面加上Model model，然后在方法体中用model.addAttribute(String attributeName, Object attributeValue); 第一个参数是写入model的对象的名字，类型String，这个名字是前端要通过对象名进行访问时所要用到的名字，也可以理解是bean的名字，第二个参数就是该对象了 视图层 在main/resource/templates下编写模板文件，此处用到thymeleaf，当然也可以用其他的，&lt;html&gt;标签内不需要任何命名空间都能够进行渲染，写了一些其他教程上提到的官方命名空间还要出错。。。 之前的就这样写：&lt;form th:action=&quot;@『/login』&quot; th:object=&quot;$『user}』&quot; method=&quot;post&quot;&gt; 输入的值关联到form里的什么值就th:field=&quot;*『username』&quot;，*号代表th:object的对象，这里就是表示该输入的时user.username的值,官方文档提示表单传值需要th:object和th:field配合使用 即使前端自写的模板html中有这些thymeleaf的标签，但是到前端渲染后的且直接时静态的值，已经被替换掉了，所以不可能在浏览器调试里面改一个标签的th:field就出bug了 在前端获取后台传值时，例如：&lt;span th:text=&quot;$『user.username』&quot;&gt;&lt;/span&gt;，这里的user就是后台写入model中的字符串的值，名字一一对应。 另外一个很重要的就是&lt;a&gt;标签进行跳转，不需要th:action=”@『/url』”，直接href=”/url” 浏览器测试 附录1：异常处理记录（会持续更新） Repository接口按照规定方法命名规则进行查询时，JapRepository时继承了Repository接口的，肯定能实验Repository的功能，但如果方法名没有按照规范写，就会出现该接口的bean创建失败，进一步导致自动注入了该bean的其他类创建失败，一般提示某个bean创建失败就是该类里面有错 常见的HTTP错误： 400：请求出错 404：找不到页面 405：不允许此方法，比如说不支持post而用了post 500：内部服务器出错，在控制台会抛出异常 502：网关出错：比如说19大期间访问谷歌。。。 Thymeleaf渲染出错，表示前端标签有问题，报错的提醒是Neither BindingResult nor plain target object for bean name “[这就是你的bean的名字]” available as request attribute，也就是说前端表单提交的的信息汇总成一个bean就出错，怎么解决 试了很多次，第一次的/login也没有写过参数，但也没有报错，但是在提交很多信息的表单的时候就要报错 *所以在某一个页面有啥对象的时候，还是在进入这个页面的的控制方法中加一个某对象在方法参数列表里为好。 出现啥BindingResult的错误，提示是An Errors/BindingResult argument is expected to be declared immediately after the model attribute 自己写的文件没有错，但是就有这个错，把参数列表里的BindingResult类去掉就行了 出现405错误的解决方案 @PostMaping互改@GetMapping就行。 也有可能是转发(forward)造成的，有一种情况就是@GetMapping向@PostMapping转发的时候，比如说自己写的分页，删除，这里就需要重新进行首页的查询，代码量比较大，且有重复。 附录2：更新提示beta V2.0 完善Controller层的url访问，后台接受参数，传参笔记的编写 新增视图层的笔记 新增附录，添加第一条Thymeleaf的常用标签 新增异常处理记录 修改部分代码块的缩进问题，把英文大括号改成中文状态下，避免语法错误。 ©2017 shic.top All Rights Reserved","categories":[{"name":"IntelliJ IDEA","slug":"IntelliJ-IDEA","permalink":"http://shic.top/categories/IntelliJ-IDEA/"},{"name":"Spring Boot","slug":"IntelliJ-IDEA/Spring-Boot","permalink":"http://shic.top/categories/IntelliJ-IDEA/Spring-Boot/"}],"tags":[{"name":"IntelliJ IDEA","slug":"IntelliJ-IDEA","permalink":"http://shic.top/tags/IntelliJ-IDEA/"},{"name":"Spring Boot","slug":"Spring-Boot","permalink":"http://shic.top/tags/Spring-Boot/"}]},{"title":"单元测试","slug":"UnitTest","date":"2017-10-07T16:00:00.000Z","updated":"2017-10-15T06:56:50.122Z","comments":true,"path":"2017/10/08/UnitTest/","link":"","permalink":"http://shic.top/2017/10/08/UnitTest/","excerpt":"Spring Boot，spring data JPA的单元测试 两种…","text":"Spring Boot，spring data JPA的单元测试 两种… 直接在test的相应目录中测试有关的repository功能 测试类前写好两个注释@RunWith(SpringRunner.class)和@SpringBootTest，这种仅仅能测试方法写对没 代码：123456789101112131415161718192021 package top.shic.repository;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;import org.springframework.test.context.junit4.SpringRunner;@RunWith(SpringRunner.class)@SpringBootTestpublic class EmployeeRepositoryTest &#123; @Autowired private EmployeeRepository employeeRepository;//自己写的EmployeeRepository的Repository接口 @Test public void findEmployeeByName()&#123; employeeRepository.findByName(\"二\");//但最好是把查询结果打印出来，方便查看结果是否正确 &#125;&#125; 测试JPA。要区分get/post等的方式，就需要在类前加上@AutoConfigureMockMvc注解，在类中也需要一个MockMvc类型的变量（重点） 代码示例： package top.shic.controller; import org.junit.Test; import org.junit.runner.RunWith; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.boot.test.autoconfigure.web.servlet.AutoConfigureMockMvc; import org.springframework.boot.test.context.SpringBootTest; import org.springframework.test.context.junit4.SpringRunner; import org.springframework.test.web.servlet.MockMvc; import org.springframework.test.web.servlet.request.MockMvcRequestBuilders; import org.springframework.test.web.servlet.result.MockMvcResultMatchers; import static org.junit.Assert.*; @RunWith(SpringRunner.class) @SpringBootTest @AutoConfigureMockMvc//这里测试的是JPA，所以也要区分是get，post等方式 public class GirlControllerTest { @Autowired private MockMvc mvc;//需要用到它 @Test public void girlList() throws Exception { //下面是测试get的访问方式 mvc.perform(MockMvcRequestBuilders.get(\"/girls\")).andExpect(MockMvcResultMatchers.status().isOk()); } }","categories":[{"name":"IntelliJ IDEA","slug":"IntelliJ-IDEA","permalink":"http://shic.top/categories/IntelliJ-IDEA/"},{"name":"Spring Boot","slug":"IntelliJ-IDEA/Spring-Boot","permalink":"http://shic.top/categories/IntelliJ-IDEA/Spring-Boot/"}],"tags":[{"name":"IntelliJ IDEA","slug":"IntelliJ-IDEA","permalink":"http://shic.top/tags/IntelliJ-IDEA/"},{"name":"Spring Boot","slug":"Spring-Boot","permalink":"http://shic.top/tags/Spring-Boot/"}]},{"title":"Spring Boot的Controller注解","slug":"springBootController","date":"2017-10-06T16:00:00.000Z","updated":"2017-10-15T06:56:50.099Z","comments":true,"path":"2017/10/07/springBootController/","link":"","permalink":"http://shic.top/2017/10/07/springBootController/","excerpt":"1.5.7版本中的Controller注解当你发现教程和你想使用的某个东西版本不一样的时候，总会觉得有些打脑壳","text":"1.5.7版本中的Controller注解当你发现教程和你想使用的某个东西版本不一样的时候，总会觉得有些打脑壳 说得又想放表情包了，先往下看。。。 环境及IDE JDK 1.8 Spring Boot 1.5.7.RELEASE maven 3.5 IntelliJ IDEA 2017.1.1 问题由来： 教程使用的是Spring Boot 1.4.1 我使用的是1.5.7.RELEASE 问题出现： 在使用Controller注解时，1.4.1就会出现500的错误（服务器内部错误），但是我用的1.5.7. RELEASE版本，就没有500的错误，但是有404错误。 分析与思考： 500的服务器错误就是因为：1.4.1版本需要使用到模板，然后方法返回一个字符串去匹配同名的视图，但是1.5.7. RELEASE版本是404错误，感觉就不是服务器出错了，只是说404错误，是找不到页面，那按照这个道理来说，1.5.7. RELEASE版本在用配置好的URL访问时就不是因为缺少模板文件导致的了。 通过查看了一下1.4.1需要怎么使用模板文件发现还是比较麻烦的，要是之后的版本取消这么使用就好了。 于是去spring boot官网找答案： 其中给的例子是：123456789101112131415161718192021package hello;import org.springframework.boot.*;import org.springframework.boot.autoconfigure.*;import org.springframework.stereotype.*;import org.springframework.web.bind.annotation.*;@Controller@EnableAutoConfigurationpublic class SampleController &#123; @RequestMapping(&quot;/&quot;) @ResponseBody String home() &#123; return &quot;Hello World!&quot;; &#125; public static void main(String[] args) throws Exception &#123; SpringApplication.run(SampleController.class, args); &#125;&#125; @Controller对比@RestController： @RestController在声明类前面注释之后，在需要通过URL访问的方法前面注释@RequestMapping()就行了 @Controller多了两个注释：一是@Controller下方的@EnableAutoConfiguration，二是方法前的@ResponseBody，**实测只需要@ResponseBody就能成功访问了而不会出现404错误。（ResponseBody意思就是注解一下回复的主体吧，这样就很好理解了） 当然在1.4.1中使用@Controller后面在加上@ResponseBody就等同于@RestController了，但在1.5.7中@ResponseBody却是放在了要通过URL访问得方法体前。","categories":[{"name":"IntelliJ IDEA","slug":"IntelliJ-IDEA","permalink":"http://shic.top/categories/IntelliJ-IDEA/"},{"name":"Spring Boot","slug":"IntelliJ-IDEA/Spring-Boot","permalink":"http://shic.top/categories/IntelliJ-IDEA/Spring-Boot/"}],"tags":[{"name":"IntelliJ IDEA","slug":"IntelliJ-IDEA","permalink":"http://shic.top/tags/IntelliJ-IDEA/"},{"name":"Spring Boot","slug":"Spring-Boot","permalink":"http://shic.top/tags/Spring-Boot/"}]},{"title":"Python初学","slug":"pythonTest","date":"2017-09-26T16:00:00.000Z","updated":"2017-09-28T06:01:05.481Z","comments":true,"path":"2017/09/27/pythonTest/","link":"","permalink":"http://shic.top/2017/09/27/pythonTest/","excerpt":"初敲Python后的一些感受 常敲Java的我开启了Python之路","text":"初敲Python后的一些感受 常敲Java的我开启了Python之路 最开始觉得Python很方便，方便程度：Python&gt;Java&gt;C++ 然后没看书了自己摸索直接敲，觉得Python很不友好 最后发现问题是自己没好好看书。。。 于是在今天把杂事都处理了之后我便自己实验了起来。 我最想了解Python的项目结构。原因有二： 之前学C的时候全是一个文件在玩儿，感觉就是限制了开发，毕竟一个文件要么功能单一，要么有功能但臃肿庞大不利于后期阅读。 之后学C++，通常是自己写需要功能然后把它们封装成类写在一个头文件里，然后以后需要用了就直接include，就特别方便，然后功能也可以实现很多。之后的Java就不多说。所以现在特别想了解一下Python的项目结构可以是什么样的，我能根据它来写出什么样的功能。 因为我没有看懂网上的教程，苦逼的我便开始了试验： 项目结构： hello1 D:\\MyProject\\PyCharmProjcet package_test _ init _.py p_test.py service_package_print.py service_obj.py service_print.py test.py 测试在根目录下从另一文件里调用函数输出，测试文件test.py service_print.py: def if_print(): print(\"这是项目根目录下的if_print()\") s=0 for i in range(1,101): s+=i print(s) service_obj.py: class service_object: #如果这里写s=2，在函数里就用不了，全局没用？ #print(s) print(\"这是项目根目录下的test_object类\") def if_print_the_sum(): s = 2 for i in range(1, 201): s += i print(s) def if_print_str(str): print(str) test.py import service_print import service_obj import package_test # service_print.if_print() # service_obj.test_object.if_print_the_sum() my_class=service_obj #id(my_class) my_class.service_object.if_print_str(\"my_class.service_object.if_print_str输出\") my_object=my_class.service_object # id(my_object) my_object.if_print_str(\"my_object.if_print_str输出\") 结果：* 通过实验，了解到了python与Java等语言不同： 类名和文件名可以不同 一个类的实例是需要file_name.class_name来赋值，Java中文件名和类名必须是一样的，所以my_object=file_name也差不多能解释。但python里文件名和类名一样后也不行。 而且python里还可以直接用file_name.function_name()来执行类中方法不需要对象.#注意：是不能使用类名直接调用的。 之后再测试了package里是怎么回事 ： 建立package后，包里面会默认有一个_ init _.py 文件，暂时不知是干啥的 然后import 这个包，发现不会用。。 但是问了一下豆豆，她却给我说她只用过directory没用过package。。.于是我有趣尝试了一下directory,结果发现只比package少了一个_ init _.py，也用不了。.. 但实际上，但仔细阅读Python模块定义后才明白，.py就是一个模块，而在Java中.java可以说是一个类，我们要用一个模块就像在Java中要用一个类一样，所以要 import package_name.module_name #这样使用 但很奇怪的一点是，import一个包里的模块后，例如上面这样，在使用的时候却不能直接使用里面的模块，这一点我搞不懂为什么，要package_name.module_name这样使用，例如我想使用service_package_print模块： 而我用 from package_test import service_package_print 就直接能够使用service_package_print模块而不需要先调用包名，且想要调用直接调用包都不行，因为这里是从该包中直接import的一个模块，要是能调用包名的话，那肯定可以调用包中的其他模块，这不符合from..import..的逻辑","categories":[{"name":"Python","slug":"Python","permalink":"http://shic.top/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://shic.top/tags/Python/"}]},{"title":"SSD揭秘篇","slug":"SSD揭秘","date":"2017-09-16T16:00:10.000Z","updated":"2017-09-17T11:44:55.966Z","comments":true,"path":"2017/09/17/SSD揭秘/","link":"","permalink":"http://shic.top/2017/09/17/SSD揭秘/","excerpt":"SSD何方神圣？一探究竟 认识好SSD的内在，几年不卡我记得在我接触SSD初期的时候，就知道它的高性能和寿命特点，再加之这货很贵，我便觉得使用时不能马虎，万一盘挂了还不好做数据恢复，最重要的是这么贵的盘挂了，自己得多心疼啊。。。","text":"SSD何方神圣？一探究竟 认识好SSD的内在，几年不卡我记得在我接触SSD初期的时候，就知道它的高性能和寿命特点，再加之这货很贵，我便觉得使用时不能马虎，万一盘挂了还不好做数据恢复，最重要的是这么贵的盘挂了，自己得多心疼啊。。。 于是乎，我便有了很强烈得想要了解它得想法，虽然说网上也有关于使用的一些帖子，诸如说的不要随时清理垃圾，盘不要分多了，M.2不同针脚的插槽的区别等，其实看完也很懵，我自己想要理解还是需要自己去从更加底层的原理看起，才能明白，于是我就去搞了一本书，里面还是讲了很多基础知识的： 终于，了解了真相。。。知道了它是怎么回事 首先是要了解固态的基本构成，怎么选择才能选到最好的方案 其次就是了解固态的运作机制，怎么的盘才是最适合自己的 最后要了解固态的存储机制，才能知道是怎么损耗的，才能知道怎么正确的使用 有了以上3点的铺垫，才能通过自己的了解，选到一个适合的SSD，且自己也会正确的使用，这在SSD价格居高不下的今天，是最最最值得思考和研究的问题，花大价钱但有优秀而长久的体验，也是很值的了，那么下面我们就分点讲解一下。 深入了解固态硬盘由于要深入了解，所以我又准备分几点以问答形式来讲，方便大家的理解： 为什么叫固态硬盘？答：固态硬盘的英文全称是：Solid State Disk，俗称固态盘，它内部和传统的机械硬盘不同，里面没有机械活动地组件，也不需要碟片旋转来读写数据，里面全是一块一块的固定的闪存颗粒，所以才叫固态硬盘 NAND闪存颗粒是怎么个回事？答：由上一点可知，固态的存储是由固定在电路板上的闪存颗粒组成的，而这里的闪存颗粒，我们就叫的NAND闪存，NAND闪存还是分了很多种的，目前有SLC.MLC.TLC,而还有正在研发的QLC，SLC全称是Single Level Cell，即1bit/cell，特点就是速度块，寿命长，但是它的成本很高，SLC利用正负两种电荷，一个浮动栅存储1bit的信息，其擦写次数约10万次的PE（擦写），MLC全称是Multi Level Cell，即2bit/cell，特点是速度中等，寿命中等，价格也处于中等水平。利用不同电位的电荷，一个浮动栅存储2bit的数据，约3000~10000次的PE，而TLC颗粒。即Triple Level Cell，3bit/cell，是三者之中速度最慢，寿命最短，价格也最低的。虽然如此，但是TLC颗粒都要比机械硬盘的存储速度快很多。但TLC颗粒的SSD也是机械硬盘的几倍价格，所以目前亲民的一些SSD基本都是TLC颗粒的。 固态硬盘的不同接口是？答：此处我们只讲两个最常见的接口，因为相对值得购买的产品也是这两大接口最多做好选。分别是SATA和m.2（顺带一点PEI-E） （1）.SATA：首先要明确一点，SATA接口在机械硬盘时期的确辉煌过，它从SATA1.0（大概150MB/s）升级到了现在的SATA3.0(大概600MB/s)，机械硬盘的速度根本喂不饱它，但是到了固态硬盘流行的年代，最高6Gbps的速率封顶也就768MB/s，现在动辄就彪2000MB/s+的速率的NVMe SSD早已不在适合搭配SATA接口了，如果你电脑只能装SATA的SSD，那么可以购买相关产品去给老电脑升级，如果不是的话，那这类产品就不用去考虑了。当然有些笔记本电脑可能有mSATA接口，它本质上还是SATA，只不过是比标准版的外观规格要小，性能都是一样的。适合于轻薄设备，但价格也比SATA贵，还不如改光驱的方案来的划算。（2）.m.2:该接口最开始是在2012年由英特尔等厂商提出的固态硬盘适用的接口，最初叫做NGFF，最终命名为了m.2(M.2)，因为期接口小巧，且能配合PCI-e通道进行使用，性能是非常强悍，目前是市面上最为火热的固态接口之一，当然还有就是以PCI-e形式存在的SSD，一般为台式机使用，直接插在主办上的PCI-e插槽上，它与m.2走PCI-e通道的SSD差别不大，笔记本用户主要就看m.2接口的SSD就行了（主板上有该接口的情况下） 不同的接口有什么差异？答：SATA3.0是目前最新的版本，是走SATA通道。最快也就6Gbps的速率。市面上的SATA盘最快也就550MB/s。而m.2走PCI-e通道的就还要分细一些。它还存在着通道和协议等方面的差距。m.2是一个接口，或者你可以叫它插槽，和SATA，mSATA（串口），IDE（并口）是同级别的。但m.2接口又细分为两种，一种是B key（又叫Socket2）。另一种是M key（又叫Socket3），两者因为接口金手指的缺口和针脚数不同而容易产生兼容性问题，大家可以去查一查其他资料看看两种m.2模组的外观有什么不同。而M.2和PCI-e的结合可以让SSD SATA和PCI-e总线标准有什么直观区别？答：我们熟悉的6Gbps的SATA接口是走SATA3.0的总线。速率顶天也就600MB/s，而有些m.2 SSD能达到2000MB/s多的速率，而这些SSD后面还经常伴随着PCI-e这个名词。而这里的PCI-e是一个和SATA3.0对应的另一个总线标准，或者叫其通道。现在市面上的一般是PCI-e3.0*4，一条PCI-e3.0能提供的带宽是8Gbps，乘以4后也就是32Gbps，最高4GB/s的传输速率，这可谓是大大得提高了原来SATA3.0只有600MB/s左右的巅峰速率。 哪是不是所有的M.2 SSD的速率都是这么高呢？答：答案是否定的。我们先来理一下。之前说了m.2接口还分B key和M key不同的模组。而m.2仅是接口，也是可以走SATA总线的。在此文字都是乏力的，我们用如下图片进行讲解，相信一下就会觉得明白：/首先感谢一下帮我截这张大图的女生，嘻嘻/所以就只有M.2走PCI-e 3.04的且支持NVme协议的SSD才能达到哦啊我们理想中的2GB/s以上的速率* SSD的大脑–主控浅析解：简单的一句话，SSD的主控就和电脑的处理器一样重要，就像大脑一样负责着整个机体的运转。SSD主控的性能好坏直接影响到SSD的使用体验。主控芯片会负责合理调配各个不同的闪存芯片上的负荷，数据的中转，NAND颗粒的磨损平衡，还有ECC纠错，坏块映射，读写缓存（存内置缓存中，一般为DDR），垃圾回收，数据加密等操作，可谓是任务繁忙。所以我们在选择的时候就必须选一个不错的主控才行。而好的主控一般就只有一线品牌才会搭载。因此，我们在选择的时候千万不能图便宜去买一个没听过的杂牌，这类产品往往是价格相对较低，但是体验却和好的产品差别很大，所以我们应该去选择一线品牌来保证我们有一个优秀的体验，即使它贵一些也值。 ▶（大知识点）SSD有使用寿命，那怎么使用才算科学？答：作为一个学生，大出血买一个SSD，真的希望它能用得越久越好，但是怎样才能让它用得久，怎样才知道自己的使用是不是科学的呢？其实就使用来说是特别复复杂的事情，因为每一个人的使用标准不同，这套使用方法或许换一个人就不适用了，都是见仁见智的事情。那么最有效的方法就是了解SSD内部关于存储这一块的知识。（1）擦写放大HDD(机械硬盘)的读写单位是扇区（Sector），一般大小为512KB。SSD的读写单位是页（Page），一般大小为4KB或8KB，但是SSD在进行擦除造作的时候，则是以块（Block）为单位，一个块通常是包含了128或者256个Page，那么一次擦除就是512KB或2MB（或其他值），假如说你要删除的文件不到512KB或者2MB，那么这一个完整的块当中的其他数据就会被这样的擦写给删除掉，那么为了避免这种逻辑上的错误，SSD的主控就会先把不删的数据转移到其他块当中，然后再执行删除之前的块，最后再把移动暂存的数据给移动回去（也有说法是不移回去）。于是乎这样一来，进行擦写时就会多擦写一些块，而造成擦写放大，增加SSD的擦写次数，增加损耗，减少其寿命。当然这也只是一个大概，类似于脏块的概念也还没有介绍，但我们可以明白一点的就是SSD的擦写，我们就知道对应着怎样去结合自己需求来科学使用了。（2） FTL(Flash Translation Layer) 闪存转换层正因为SSD的每一个存储单元都有寿命可言，且其擦写和HDD有本质上的不同，但为了保障上层操作系统和文件系统的一致性，SSD的主控会来隐藏这一不同的处理过程的区别，让我们用SSD时和用HDD时感受不到差别，这就引入了FTL，闪存转换层。操作系统在读取文件时，会根据一张叫LBA的表去查询数据的地址，LBA（Logical Block Address）就是逻辑块地址，查询得到该数据在硬盘中的物理地址PBA（Physical Block Address）。很显然LBA到PBA的关系是一张映射表，就像警察要找你，首先去看一下翻一下LBA查到你家在哪，然后再去这个地址找你一个道理。但是由于固态每一个存储单元都是有寿命的，出于磨损平衡（下一点会讲）的需要，同一个LBA对应的PBA并不是固定的，这一张表一直处于变动中，让主控来处理动态关系，所以又提到了主控，它的性能好坏真的很影响体验呀。（3）磨损平衡磨损平衡也就是很多时候我们所看到其他文章中说的Wear Leveling。还是因为SSD的闪存颗粒的寿命，是以擦写次数来计算的，也就是P/E次数。如果数据就按照存储单元的物理地址递增的顺序来存储的话，那么前面的空间就会出现反复擦写的情况，这样就会造成前面这些空间有更多的擦写，就会更快的消耗完其寿命，这一片区域就损坏了。所以就需要引入磨损平衡的机制，也就是结合上一条写的FTL，对LBA和PBA进行科学的转化，保证所有的物理块的擦写（磨损）都能够被控制在一个大致相同的范围内。（4）垃圾回收 Garbage Collection(GC)以前我们用HDD的时候，应该都知道一个叫磁盘碎片整理的功能，但是这个功能对于SSD不适用，它会增加SSD的磨损。所以SSD需要一套新的机制，那就是垃圾回收，简称GC。其原理就是在SSD空闲的时候，全盘扫描有效的页并整理起来形成一个含有全部有效页的块，而那些无效页和块和页就被彻底清理了。而伴随这GC的另一个名词就是Trim，本质是一个ATA指令，作用在于让操作系统发出指令给SSD的主控，告诉它那些数据占用的地址是无效的，然后主控就会在这些地址上做一个标记，表面这里的数据是无用的。然后与GC配合后，就能在SSD进行GC时跳过这些这些无用的数据不被整理在一个有用的块当中，这样在节省时间的同时，也可以减少无用的写入，降低闪存的损耗，Trim本身并不能大幅改善SSD的性能，但是与GC协同工作后，却能达到事半功倍的效果，能让SSD在使用一段时间后依然能维持在一个不错的性能水平上。这也叫被动GC，有关主动GC方面的就暂时不讲了，不是所有的SSD都有主动GC，但都有被动GC。 至此，5000字的长文就结束啦，如果真的要写SSD揭秘的话，或许可以写一本书，所以本文只是一个很简短而又精华的介绍，博主这一周多来，每天都用了些课余的时间给大家写这篇文章，在查阅资料的同时还站在读者的角度去思考，怎样才能写得更加明白，怎样才能在对SSD一无所知得情况下看懂。如果你真的希望自己了解SSD，那么你真的要每一句都认真阅读过，也不枉费我的良苦用心，希望朋友们都能够不花冤枉钱而买到自己最合适的产品。如果有任何问题，欢迎通过微博私信联系上我。 版权所有，转载请注明出处","categories":[{"name":"让电脑飞","slug":"让电脑飞","permalink":"http://shic.top/categories/让电脑飞/"}],"tags":[{"name":"让电脑飞","slug":"让电脑飞","permalink":"http://shic.top/tags/让电脑飞/"}]},{"title":"百公里去眉山","slug":"RunTimeToMeishan","date":"2017-09-16T16:00:00.000Z","updated":"2017-09-17T11:34:46.175Z","comments":true,"path":"2017/09/17/RunTimeToMeishan/","link":"","permalink":"http://shic.top/2017/09/17/RunTimeToMeishan/","excerpt":"山路漂移进眉山2017年9月16日周六，我们按照原来约好的时间，汇集在一起准备去望鱼了，那地方的风景一般，但沿路上是时上时下的山路，当地政府还修的草油路，这样的山路骑车就会感觉特别爽。给我们飙车党一种深陷其中，无法自拔的体验，而在一个长上坡时，大腿都会发软，心想只要过来这个上坡，下面马上就会有一个下坡可以好好爽一把，因为车辆很少，我们自行车时速超50都没问题。路上我们放着音乐，特别带感，特别欢乐。途中放了一首初三时学校里经常放的歌，很有感触，让我想起了那个比现在还快乐许多的时光，歌中唱到了“爱拼才会赢”，正是对我们劳累后的鼓舞。","text":"山路漂移进眉山2017年9月16日周六，我们按照原来约好的时间，汇集在一起准备去望鱼了，那地方的风景一般，但沿路上是时上时下的山路，当地政府还修的草油路，这样的山路骑车就会感觉特别爽。给我们飙车党一种深陷其中，无法自拔的体验，而在一个长上坡时，大腿都会发软，心想只要过来这个上坡，下面马上就会有一个下坡可以好好爽一把，因为车辆很少，我们自行车时速超50都没问题。路上我们放着音乐，特别带感，特别欢乐。途中放了一首初三时学校里经常放的歌，很有感触，让我想起了那个比现在还快乐许多的时光，歌中唱到了“爱拼才会赢”，正是对我们劳累后的鼓舞。 途中的风景一般，也没怎么停过，主要是飚车太爽了，哈哈哈 途经望鱼已是中午，我们吃饭后稍作休息冲了一哈壳子 但昨天我们却再往前骑了一段，意外得来到了眉山洪雅境内，在交界处我们拍了一张纪念照。 但在这之后发现了不一样的美景，当然我们也是要上很多坡的，中途也是很累，骑着大腿乏力，屁股感觉要燃烧了一样，一直期盼着有一个下坡爽一爽，但没想到过了一个几百米的黑洞之后，呈现在眼前的景色却让我们大吃一惊，这种感觉特别棒，先上一张全景图图看看，可能有点大，但是效果应该特别棒:)(这里的水就很不一样，看旁边的介绍牌就说的是常年维持在国家Ⅱ类水质标准)(和自行车一起拍照是不是有一种别样的风采) 这还有一对新人在这里拍照，我们仨应该都祝福了他们吧，嘿嘿嘿 据说这湖泊叫雅女湖，雅女湖又称瓦屋山水库。地处四川省西沿的眉山市洪雅县瓦屋山森林公园境内。海拔高度达1080米。湖面积15平方公里，湖长19.04公里，湖宽13.31公里，水均深16米。库容6亿立方米，坝高为143米，来看一下地图上我们所处的位置就知道它有多大了 当然图片可能有些乏力，毕竟画幅没有达到一定要求是不能感受到像人眼看到的样子，那再放一个经过同学去掉了杂音的视频吧，嘻嘻 我们要准备离开的时候都已经15：40了，在聚雅女湖还有7公里那有一户人家淳朴热情，还为我们提前烧好了开水凉着等着我们回来饮用，缓解一下我们的疲劳，还为我们提供可口的黄瓜，让我们在他们那休息再出发。真的特别温暖，谢谢您带给了我们感动，最后挥手道别的“一路平安”一直温暖了之后的整个路程，是您的热情让这个美丽的地方更加迷人。 我们与16点10多分的样子从好心阿姨家出发，又一次地跨过了交界处，骑陡坡累哭，下陡坡爽哭，中途有下雨我们也冒雨赶路，因为中途等一个骑得慢点的同学，所以回到学校时都已经19点。饥寒交迫的我们，便狼吞虎咽了起来，分分钟就。。。。 回到寝室楼下后，我们看了一下码表的数据，虽然很劳累，但却感到骄傲，我再一次打破了我们自己骑山路的数据，真的特别开心，特别感动 想表达什么呢？我们以后再约～","categories":[{"name":"漂移","slug":"漂移","permalink":"http://shic.top/categories/漂移/"}],"tags":[{"name":"漂移","slug":"漂移","permalink":"http://shic.top/tags/漂移/"}]},{"title":"超强string类","slug":"C++string","date":"2017-08-30T16:00:00.000Z","updated":"2017-08-31T13:40:41.287Z","comments":true,"path":"2017/08/31/C++string/","link":"","permalink":"http://shic.top/2017/08/31/C++string/","excerpt":"C++里的string用得不爽怎么办还记得我20岁生日那天，上午帮一女生改代码，下午参加了一个编程活动，我选的语言是C++，然后，TMD居然装备忘带了。。。。晚上虽然和室友出去小搓了一顿，但心里还是惦记着我忘带的装备，没了信仰的加成，电脑都要蓝屏。。","text":"C++里的string用得不爽怎么办还记得我20岁生日那天，上午帮一女生改代码，下午参加了一个编程活动，我选的语言是C++，然后，TMD居然装备忘带了。。。。晚上虽然和室友出去小搓了一顿，但心里还是惦记着我忘带的装备，没了信仰的加成，电脑都要蓝屏。。 其实C++挺好的，我我一直很努力的学习，上马克思课我都在看，我觉得C++的编程书真的好看，特别是C++ Primer Plus 堪称C++界的巨著，奈何时间紧促，我老是想开发个规模大的东西，于是后面因为某些原因就入了JAVA的坑，但是面向对象的思想我在C++里却学到了很多。我的装备好多都因为一次电脑硬件的变动而不见了，不知仍那去了，今天还找到了以前改的string类（基于某个初级版本），给它加了点料 string1.h /*这是一个增强（自己修改过的）string类，类名是String，可以实现直接用字符串复制给这个String类的对象 ，还可以把这个类对象想字符数组一样输出第几个字符，还可以想正常的string类的对象一样的输出输入，做加法， 判断哪个长，变换大小写等运算使用时包含string1.h的头文件，并注意放的文件夹位置*/ //如果报错说strcpy等不安全就加这个：#define _CRT_SECURE_NO_WARNINGS//关闭安全检查 #ifndef STRING1_H_ #define STRING1_H_ #include #include using std::ostream; using std::istream; class String { private: char * str; // pointer to string int len; // length of string static int num_strings; // number of objects static const int CINLIM = 80; // cin input limit public: // constructors and other methods String(const char * s); // constructor String(); // default constructor String(const String &); // copy constructor ~String(); // destructor int length() const { return len; } // overloaded operator methods String & operator=(const String &); //重载 赋值运算符函数 对象赋对象 String & operator=(const char *); //重载 赋值运算符函数 字符串赋值对象 String operator+(const String &); //重载+号 char & operator[](int i); const char & operator[](int i) const; // overloaded operator friends friend bool operator(const String &st1, const String &st2); friend bool operator==(const String &st, const String &st2); friend ostream & operator (istream & is, String & st); // static function static int HowMany(); //大小写转化，包含头文件 写：#include void Stringlow(); void Stringbig(); }; #endif --下面是方法实现 **string1.cpp** #include \"string1.h\" #include // string.h for some #include using std::cin; using std::cout; //有些用的strcpy，有些是strncpy。。反正都要报错说不安全 // initializing static class member int String::num_strings = 0; // static method int String::HowMany() { return num_strings; } // class methods String::String(const char * s) // construct String from C string { len = std::strlen(s); // set size str = new char[len + 1]; // allot storage std::strncpy(str, s, len + 1); // initialize pointer num_strings++; // set object count } String::String() // default constructor { len = 4; str = new char[1]; str[0] = '\\0'; // default string num_strings++; } String::String(const String & st) { num_strings++; // handle static member update len = st.len; // same length str = new char[len + 1]; // allot space std::strcpy(str, st.str); // copy string to new location } String::~String() // necessary destructor { --num_strings; // required delete[] str; // required } // overloaded operator methods // assign a String to a String String & String::operator=(const String & st) { if (this == &st) return *this; delete[] str; len = st.len; str = new char[len + 1]; std::strncpy(str, st.str, len + 1); return *this; } // assign a C string to a String String & String::operator=(const char * s) { delete[] str; len = std::strlen(s); str = new char[len + 1]; std::strcpy(str, s); return *this; } String String::operator+(const String &s) { String sum; sum.len = len + s.len; sum.str = new char[sum.len + 1]; std::strcpy(sum.str, str); std::strcat(sum.str, s.str); return sum; } // read-write char access for non-const String char & String::operator[](int i) { return str[i]; } // read-only char access for const String const char & String::operator[](int i) const { return str[i]; } // overloaded operator friends bool operator","categories":[{"name":"C++","slug":"C","permalink":"http://shic.top/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://shic.top/tags/C/"}]},{"title":"UEFI番外篇","slug":"UEFI2","date":"2017-08-26T16:00:10.000Z","updated":"2017-08-27T01:28:15.439Z","comments":true,"path":"2017/08/27/UEFI2/","link":"","permalink":"http://shic.top/2017/08/27/UEFI2/","excerpt":"改传统于UEFI，你知道这些就够了在跟着上一篇改动了启动模式后是不是觉得UEFI很快呢，那么本篇就来简单讲讲UEFI和传统BIOS的一些区别以及为什么它要快些，作为一个Geek，光用肯定是不舒服吧，要弄清楚道理可能才是最好的","text":"改传统于UEFI，你知道这些就够了在跟着上一篇改动了启动模式后是不是觉得UEFI很快呢，那么本篇就来简单讲讲UEFI和传统BIOS的一些区别以及为什么它要快些，作为一个Geek，光用肯定是不舒服吧，要弄清楚道理可能才是最好的为了简单明了地弄懂这个问题，我通过自己的总结和举例，帮助读者懂明白。虽然有些可能不是100%的准确，但大致可以这样理解。 UEFI采用的不同的开机引导首先我们明白，我们的系统是放在硬盘里的，那些数据是用一个容器来装着的，但硬盘里那么多的数据，计算机怎么知道开机需要哪一块的呢？所以开机的时候需要引导，像一个指挥棒一样，指引着硬件怎么去利用特定的数据。这里的引导模式就有些不同了，这在我们装系统的时候就能看出来，需要一个盘去引导硬件开机。传统的安装系统，在安装的时候会出现添加引导，其中你把系统装入的分区就是引导分区，如上图一样我把系统装在C盘，添加的引导就是C盘，且推荐也是C盘，意思是要用它来引导开机，而UEFI模式下，从装机时的引导就能看出不一样，需要的引导不是系统所在分区，而是我们建立的ESP分区了。如下图：我把系统装在C盘，但UEFI下的引导并不是C盘的，而是我们之前建立的ESP分区，就是上图所示的E盘。而从这里我们也明白了为什么要实现UEFI启动必须要有ESP分区了，还要向该分区里手动添加EFI分区文件，因为是需要用来ESP分区来引导系统的启动，而大家也会发现EFI分区文件和系统镜像文件里的boot文件夹里的EFI很像 不同EFI文件夹里的不同内容 （上方为EFI分区文件，下方为win10iso里的efi文件夹，当然里面的内容是不同的） UEFI和传统的BIOS启动方式不同我们推荐目前的电脑都采用UEFI启动是因为它开机快，为什么现在的UEFI比传统的BIOS启动快呢？原因还启动的流程不同大概可以这样分：开机-&gt;UEFI初始化-&gt;引导操作系统-&gt;进入系统而传统模式下：开机-&gt;BIOS初始化-&gt;BIOS自检-&gt;引导操作系统-&gt;进入系统这么一来UEFI开机就要快些了。所以我们推荐使用UEFI，那么我们之前在改什么硬盘的分区结构又是怎么回事呢？为此我还专门去研究了一下硬盘的分区结构，那可以不改吗？答案是：不行的，必须改。我们需要安装Windows系统，由于微软的限制，只能将系统安装在GPT硬盘中。我们以前的传统模式下，BIOS是不能识别GPT的，所以那时我们的硬盘都是MBR的分区结构，这也有了《怎样UEFI启动》一文，里面有详细的处理步骤。而经过笔者的亲自测试，如果硬盘是MBR结构，即使使用UEFI版的装机U盘，也只能是传统的启动；如果硬盘是GPT结构的，安装win7会出现“Windows无法安装到这个磁盘,选中的磁盘采用GPT分区形式”，原因是win7没有像以后的系统一样预装efi文件。只有把硬盘格式改成MBR才可以装win7。所以给大家总结一下启动模式和硬盘的分区结构的组合搭配应该是：传统BIOS+MBR硬盘，或者UEFI+GPT硬盘。 后言当然就后者UEFI+GPT硬盘，优势并不只是开机快了点，而UEFI有其他优势，GPT分区结构也有比MBR更强大的地方，因为已经超出了本文的讨论范围，所以就不赘述了。总的来说，在未来会有越来越多的UEFI+GPT的组合出现在电脑上，这应该是一个趋势所在。 欢迎转载，转载注明出处","categories":[{"name":"让电脑飞","slug":"让电脑飞","permalink":"http://shic.top/categories/让电脑飞/"}],"tags":[{"name":"让电脑飞","slug":"让电脑飞","permalink":"http://shic.top/tags/让电脑飞/"}]},{"title":"UEFI篇","slug":"UFEI1","date":"2017-08-24T16:00:00.000Z","updated":"2017-08-26T02:56:15.500Z","comments":true,"path":"2017/08/25/UFEI1/","link":"","permalink":"http://shic.top/2017/08/25/UFEI1/","excerpt":"电脑快速进入工作状态，你需要UEFI启动首先要给大家讲一个故事，我朋友的原装win8.1笔记本，APU平台+机械硬盘，说实话那台属于低端产品，但每次开机都是12秒左右，老流氓就显示开机已完成，打败99%的电脑，这就是UEFI启动，不同与传统的BIOS。要是能让电脑更快，我绝对会去折腾。17年寒假的时候我真的去折腾了，把家里的电脑拿来连着重装了5，6次，最后一次才成的，前面都没有成功，于是就不断的查资料，不断的找原因，还去学习了一些硬盘的分区结构，最后才想了想才把它整理了出来形成了两篇文稿，如果你和我一样喜欢折腾，那就可以继续往下看了。","text":"电脑快速进入工作状态，你需要UEFI启动首先要给大家讲一个故事，我朋友的原装win8.1笔记本，APU平台+机械硬盘，说实话那台属于低端产品，但每次开机都是12秒左右，老流氓就显示开机已完成，打败99%的电脑，这就是UEFI启动，不同与传统的BIOS。要是能让电脑更快，我绝对会去折腾。17年寒假的时候我真的去折腾了，把家里的电脑拿来连着重装了5，6次，最后一次才成的，前面都没有成功，于是就不断的查资料，不断的找原因，还去学习了一些硬盘的分区结构，最后才想了想才把它整理了出来形成了两篇文稿，如果你和我一样喜欢折腾，那就可以继续往下看了。关于为什么UFEI启动这么快，下篇文章会简单说明一下，那么本篇我们就先来操作一番，先把电脑启动模式改成UEFI。 首先我们要看一下我们电脑是否已经是UEFI启动了，如果是那就别看了。。。不对，键盘win+R，调开运行，输入msinfo32，就会打开一个窗口，查看里面的BIOS模式就行了，写的UEFI，那么就是UEFI的的引导模式了。如果写的是传统，那就是传统的模式。这时，我们就需要把它改成UEFI，来达到电脑开机比以前快的目的。经过我的测试，不重装系统应该是行不通的。道理也很简单，那么这里再次为下一篇精彩的文章做出预告，欢迎及时关注《改传统于UEFI，你不得不知的这些》一文的更新，好了，废话不多说，我们现在就进行操作。首先，我们做一件事需要一个规划，我们的操作要规划好，才能节约时间且达到满意的效果。首先我们的硬盘里是有重要的数据的，在进行改UEFI的过程中，需要更改硬盘的分区结构，涉及到所有的数据。当然这个在正常情况下是安全的，如果自己的电脑性能真的不好，运行软件容易卡顿，那就更加应该备份了，在运行过程中死机，那强行关机，多半会造成一些数据的损失。如果重要信息备份已经完成，或者没有可保留的数据，那么就往下看。 准备Windows系统 制作启动盘 修改磁盘分区方案 建立ESP分区 EFI分区操作 开始“刷机” 那么我们就开始分步开始操作了： 准备Windows系统 重装系统先要准备好目标系统，在vista及之后的64位系统都支持UEFI，但是只有win8及之后的系统才预装了UEFI启动所需要的启动文件。如果还想用win7的朋友，就只能自行添加相关的EFI文件到系统包里面了。而就目前的形式来看，首先的系统当然是win10了。 win8.1，efi文件夹里有boot文件里，里面还有相关的efi文件，8以后的系统都有它。Win7的efi文件夹里没有相应的boot文件夹，更没有efi的文件了，也就是没有预装efi文件。制作启动盘因为笔者喜欢用U盘装机，装机盘可以随时移动还可以外借，十分方便，所以本文就以U盘装机为例了。大家在网上去搜索相关制作U盘启动盘的软件就行，此处记住，一定要下载UEFI装机版的软件。这些软件的使用在其官网上都有使用方法，笔者在这就不赘述了。按照相关要求，把你要安装的系统放入制作好的U盘里。修改磁盘分区方案MBR和GPT是磁盘的两种不同分区方案，传统的启动模式下都是采用的MBR的分区结构，而因为微软限制，想要在UEFI下安装Windows系统只能将系统安装在GPT硬盘中，所以我们此处需要修改磁盘的分区方案。而正好有软件可以让我们把磁盘无损地从MBR转到GPT，除非小概率事件自己机器出毛病卡死造成数据损失，其他时候都是安全的。那么我们就要用到一个名叫diskgenius的软件。如果你制作的U盘启动器里面有此软件，那么选择U盘启动后，在PE里操作。如果里面没有，就下载一个放U盘里，然后U盘启动后安装此软件。进入软件后，大家可以先把系统的分区表备份到U盘中，万一真的操作失败可以将备份分区表重新导入系统盘中。我们点击软件顶部区域的“硬盘”，点击“转换分区表类型为GUID格式”。（点击确认即可） 建立ESP分区我们需要建立EFI system partition分区，这是UEFI GPT模式下必须有的分区，简称ESP分区。有些电脑上会有几百兆的隐藏空间，我们就把它删除了再建立ESP分区，如果电脑上没有这一小块的隐藏空间，那么就需要自己从C盘中分一点空间出来，当然强大的diskgenius可以完成此项任务。鼠标右键点击“调整分区大小”，设置100MB的分区大小就行了，然后选中刚分出来的区域（此时应该为灰色），建立ESP分区，如果是磁盘全部删除或者是新的磁盘，那么就会出现下面的画面 选择建立ESP分区而不是MSR分区，设置大小为100MB即可，点击确定。如果磁盘是以前用过的，也没关系，照着上面步骤操作，如果出来的界面和上面不一样，多半是因为以前硬盘引导过系统启动，该盘上已经有了MSR分区了，所以上图就不会出现，但会出现一个分区的详情选择，文件系统默认的可能是NTFS或者FAT32等，此处在选择单里面选择EFI system partition就行了，点击确定。盘符不用管。有些玩家在操作的时候说此时一定不能分配盘符，要重新启动后再来分盘符，不然要出错，其实这里涉及到的4种情况笔者都亲自试过了，不管何时分配的盘符，都能成功装机，也有可能我用的diskgenius版本号是4.9的原因吧，大家看到这篇文章时，可能5.0都出来了，所以大家不用担心，大胆进行操作。EFI分区操作建立好ESP分区后，我们需要把EFI分区文件放入ESP分区更目录。此处我建立的ESP盘符是E然后再用UEFI引导修复工具修复，挂载ESP分区，选择要装系统的根目录 开始“刷机”先进入BIOS，因为众多的主板设置不太相同，所以大家都根据这自己的情况来。在boot一项中选择启动模式，改成UEFI，或者有UEFI/Legacy字样的。保存退出。 再次进入BIOS，选择UEFI：U盘的启动，U盘可能会出现两个，要选择UEFI字样的，进入后按照标准装机步骤进行安装系统即可。 装机完成后进入系统按照上述的查看方法查看启动方式，就已经修改了。 接下来的日子里，你的电脑启动就会比以前快了。那么这个UEFI启动是不是很神奇呢，下一篇文章讲用通俗的语言来讲解一下这一原理，敬请期待吧~ 欢迎转载，转载注明出处","categories":[{"name":"让电脑飞","slug":"让电脑飞","permalink":"http://shic.top/categories/让电脑飞/"}],"tags":[{"name":"让电脑飞","slug":"让电脑飞","permalink":"http://shic.top/tags/让电脑飞/"}]},{"title":"准备起飞之SSD","slug":"SSD行情浅析","date":"2017-08-22T16:00:00.000Z","updated":"2017-08-23T03:01:18.471Z","comments":true,"path":"2017/08/23/SSD行情浅析/","link":"","permalink":"http://shic.top/2017/08/23/SSD行情浅析/","excerpt":"涨价风波一年多的SSD行情浅析希望能帮到正要买固态的你shic.top 防哈橙戌员 简介：SSD全称是Solid State Drive/Disk，顾名思义意为固态硬盘，不同于机械硬盘，它没有驱动旋转马达，没有磁盘碟片，用NAND闪存颗粒作为存储介质，是一个常见的非易失性存储。且SSD内部还有包括想主控，缓存等东西。","text":"涨价风波一年多的SSD行情浅析希望能帮到正要买固态的你shic.top 防哈橙戌员 简介：SSD全称是Solid State Drive/Disk，顾名思义意为固态硬盘，不同于机械硬盘，它没有驱动旋转马达，没有磁盘碟片，用NAND闪存颗粒作为存储介质，是一个常见的非易失性存储。且SSD内部还有包括想主控，缓存等东西。 我记得固态硬盘从去年第二季度经历了一次白菜价后，价格就一直处于上升阶段，涨到现在都还在涨，就只有2017年5月左右有一些小幅度价格平缓时期。那是不是价格一直这么涨，是不是现在就不是买的时候呢？情况获取还不是这样的，你在现在依然可以有选择。那么我们先来看一下SSD的主要两个涨价因素： 1.各大闪存颗粒厂商颗粒正处于2D NAND转3D NAND中。 2.移动市场需求火热，eMMC，UFS等都是NAND的闪存颗粒。 //3.当然也有主流厂商的抬价 的确，从现在的行情来看，固态的价格涨了太多了，一年多钱399能买一个一线大厂的240GB盘，现在可能需要600多，看似也不适合出手了，而且就目前形势来看，固态的需求依然旺盛，厂商依然还在产能转型期，所以固态预计的价格平缓和降价至少会在18年Q1，但可以确定的是，短时间不会回到16年上半年的白菜价了。简单的分析一下哪些情况可以买： 你的电脑有m.2接口 电脑真的太慢需要出血购买 1234/*1.对于第一点来说，m.2接口初期都是配合一些高端产品在出售，这类固态通常是走PCI-E通道，走SATA通道的另当别论，这类产品本身就处于高端产品，但在涨价风波中却没有过多的上涨，而且因为新技术的普及。整体还有所下降，甚至和涨价后的有些SATA接口的产品一个价位了，这样一来，性能高出好几倍的PCI-E通道的固态是不是就值了呢*/ 注：有m.2接口且支持PCI-E通道电脑的一定要配同样是走PCI-E的SSD，传统的硬盘接口SATA，全称是Serial Advanced Technology Attachment，是一种串行电脑总线，专为机械硬盘而设计的AHCI标准配合SATA接口并不能发挥出固态的全部实力，甚至因为接口性能而出现了速度瓶颈，AHIC+SATA并不适合低延迟的固态，全新的NVMe协议的PCI-E固态才是正确的选择，NVMe是Non-Volatile Memory Express的缩写，非易失性存储器标准，充分利用PCI-E通道的低延时以及并行性，降低了I/O操作等待时间、提升同一时间内的操作数、更大容量的操作队列等。性能可谓是突飞猛进 1234/*2.你的电脑真的太卡了，已经影响到自己的使用体验了，那么对于没有m.2接口的电脑，选择就2条原则，第一就是选国际一线品牌，有保障，固态硬盘是有使用寿命的。 第二就是相同价格选MLC颗粒而不是TLC。*/ 好了，不多说了，这只是简单的分析，后期还会给大家分享关于固态装机和后期使用的一些很重要的事，敬请期待吧","categories":[{"name":"让电脑飞","slug":"让电脑飞","permalink":"http://shic.top/categories/让电脑飞/"}],"tags":[{"name":"让电脑飞","slug":"让电脑飞","permalink":"http://shic.top/tags/让电脑飞/"}]},{"title":"让电脑飞系列开篇","slug":"让电脑飞前言","date":"2017-08-21T16:01:00.000Z","updated":"2017-08-23T02:52:54.298Z","comments":true,"path":"2017/08/22/让电脑飞前言/","link":"","permalink":"http://shic.top/2017/08/22/让电脑飞前言/","excerpt":"电脑怎么飞作者：防哈橙戌员 主页：shic.top 说实在的，玩机这么久了，也是时候答应小伙伴的要求了，相应你们的号召，先解决一下电脑使用的问题，还你一个高效快速的体验，我也省点心不必每次自己操作，大家去我的主页shic.top看让电脑飞相关标签的的帖子，保证你上了这趟车车再也回不去了","text":"电脑怎么飞作者：防哈橙戌员 主页：shic.top 说实在的，玩机这么久了，也是时候答应小伙伴的要求了，相应你们的号召，先解决一下电脑使用的问题，还你一个高效快速的体验，我也省点心不必每次自己操作，大家去我的主页shic.top看让电脑飞相关标签的的帖子，保证你上了这趟车车再也回不去了 会是这样的吗？ 哈哈，开玩笑啦，首先我们就需要了解两个东西 固态硬盘 英文名SSD，在磁盘界是秒天秒地秒空气的存在，特别是现在走PCI-E3.0通道的盘，相信大家都对它很有关注 UEFI UEFI全称是Unified Extensible Firmware Interface，也就是统一的可扩展固件接口的意思，可以说是近几年里要取代电脑传统启动方式BIOS的节奏了 看到这里是不是觉得很糊涂了呢，没关系，这还没开始讲嘛，即将发布的教程没什么难度，你只需要动手去跟着操作就行了，没什么看不懂的，要勇于去实践，去探索，去尝试，折腾了半天成功后，你也会有一种满满的自豪感，到时候你就知道电脑开机比电视还快有多爽了，是的，真的 很爽！！期待噢，等我更新噢~","categories":[{"name":"让电脑飞","slug":"让电脑飞","permalink":"http://shic.top/categories/让电脑飞/"}],"tags":[{"name":"让电脑飞","slug":"让电脑飞","permalink":"http://shic.top/tags/让电脑飞/"}]},{"title":"关于本站","slug":"aboutSite","date":"2017-08-21T16:00:00.000Z","updated":"2017-08-23T02:52:54.282Z","comments":true,"path":"2017/08/22/aboutSite/","link":"","permalink":"http://shic.top/2017/08/22/aboutSite/","excerpt":"为什么有本站 首先给大家讲一个故事，从前有两个程序员在聊天，A：“我昨天碰到个妹子找我，说是电脑出问题了，我觉得肯定不是只修个电脑这么简单，然后……”，B：“什么？她电脑CPU是什么型号的？”。。。很显然重点不是在CPU型号上。但有时候想想，电脑的这些配置，还真的是我们这一群人可以讨论一天的话题，虽说会修电脑的程序员应该是很少的，在我的同学中，对电脑的这些配置也了解很少，因为我们都不是学维修的，也不会学很多硬件上的东西，大多数还是软件，涉及到编程写代码。","text":"为什么有本站 首先给大家讲一个故事，从前有两个程序员在聊天，A：“我昨天碰到个妹子找我，说是电脑出问题了，我觉得肯定不是只修个电脑这么简单，然后……”，B：“什么？她电脑CPU是什么型号的？”。。。很显然重点不是在CPU型号上。但有时候想想，电脑的这些配置，还真的是我们这一群人可以讨论一天的话题，虽说会修电脑的程序员应该是很少的，在我的同学中，对电脑的这些配置也了解很少，因为我们都不是学维修的，也不会学很多硬件上的东西，大多数还是软件，涉及到编程写代码。 而我是那种对于电脑的基础部件很有兴趣的人，所以经常折腾电脑，玩儿久了也有不少的体会，也可以叫做一个小小的极客吧。借着暑假的空闲时间，简单上线了一个博客平台，分享一些关于电脑日常使用和优化的帖子，让大家也能有一个反应快速的生产力工具，提高自己的工作学习效率，这也算是我的一个课外兴趣吧，捣鼓了大半天，研究了一个啥好用的技能，能够通过自己的平台进行分享也是很有乐趣的一件事，毕竟兴趣能冲淡无聊而无线重复的平凡生活，让我们更加有活力。 本站也只是笔者的一个课外兴趣，也不做过多的修饰和更改，仅仅是一个个人博客，由于不可抗拒的原因（自己以后可能会把该博客搬到国内，也许不会，因为歪果有些云服务器的确便宜，以后搬回来再备案、所以目前暂不添加评论功能了），以后有时间可能会多一个分类，就不光是计算机的东西，我会根据实际的情况和时间节点来给大家分享一些计算机方面的知识，希望能够帮到你，如有什么问题，还可以微博私信我，每一期的文章分享我也会在微博上及时更新，希望它能够第一时间和你见面，下面的 就是我的微博，赶快加一波关注吧～","categories":[{"name":"IntelliJ IDEA","slug":"IntelliJ-IDEA","permalink":"http://shic.top/categories/IntelliJ-IDEA/"}],"tags":[{"name":"IntelliJ IDEA","slug":"IntelliJ-IDEA","permalink":"http://shic.top/tags/IntelliJ-IDEA/"}]}]}